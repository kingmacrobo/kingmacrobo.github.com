<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Hombo's Blog</title>
 <link href="http://hombo.wang/" rel="self"/>
 <link href="http://hombo.wang"/>
 <updated>2014-10-06T00:34:08+08:00</updated>
 <id>http://hombo.wang</id>
 <author>
   <name>Hombo Wang</name>
   <email></email>
 </author>

 
 <entry>
   <title>无私分享一个翻墙的好方法</title>
   <link href="http://hombo.wang/hosts/2014/10/06/hosts"/>
   <updated>2014-10-06T00:00:00+08:00</updated>
   <id>http://hombo.wang/hosts/2014/10/06/hosts</id>
   <content type="html">&lt;p&gt;这个翻墙方法是我认为最好的一种，可以随意上facebook，Twitter，Google+等被墙的网站，而且速度非常快，简单易操作。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;方法就是：点击此&lt;a href=&quot;http://pan.baidu.com/s/1bnq4dKr&quot;&gt;hosts&lt;/a&gt;文件，然后下载，把下载的hosts文件替换系统的hosts，不同系统更换hosts的方法不同，下面列出不同系统的hosts文件位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac OS X : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/private/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;最好在shell下用vi来修改，需要用户权限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows XP/Windows 7/Windows 8 : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C:\WINDOWS\system32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;需要用户权限，建议用vi+sudo来修改&lt;/p&gt;

&lt;p&gt;替换了系统的hosts文件后就可以用你的浏览器翻墙了！&lt;/p&gt;

&lt;h3 id=&quot;https&quot;&gt;注意！！上国外的网站时一定要记得在网站前面加&lt;code&gt;https://&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;例如：https://www.facebook.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个hosts文件我会定期更新，敬请关注！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>swap两个int指针指向的数</title>
   <link href="http://hombo.wang/algorithm/2014/10/05/swap-two-int"/>
   <updated>2014-10-05T00:00:00+08:00</updated>
   <id>http://hombo.wang/algorithm/2014/10/05/swap-two-int</id>
   <content type="html">&lt;p&gt;这是一道最近的面试题，感谢斌哥的奉献！
题目是： 填写下面的函数，实现a和b指针指向的两个数的交换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    *a = ________ ;
    *b = ________ ;
    *a = ________ ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;我们知道对于两个数a,b的交换，如果不借助其他变量，也是可以实现的，方法有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用加减法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用加减法的 &lt;code&gt;交换律&lt;/code&gt; 和 &lt;code&gt;结合律&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a + b;
    b = a - b; //b = a + b - b = a 
    a = a - b; //a = a + b - a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;用乘除法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，这个方法需要满足 &lt;code&gt;a*b != 0&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a * b;
    b = a / b; //b = a * b / b = a 
    a = a / b; //a = a * b / a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这个方法用到了乘除法的 &lt;code&gt;分配率&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用异或运算：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用异或的性质: &lt;code&gt;交换律&lt;/code&gt; , &lt;code&gt;结合律&lt;/code&gt;  , &lt;code&gt;a ^ a = 0&lt;/code&gt; , &lt;code&gt;0 ^ a = a&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a ^ b;
    b = a ^ b; //b = a ^ b ^ b = a ^ 0 = a 
    a = a ^ b; //a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而本题给的是指针，而且等式左边都是指针，也就是说没办法直接改变指针指向的内存位置的值，那怎么办呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法:&lt;/h2&gt;

&lt;p&gt;虽然等式左边没有给出&lt;a href=&quot;http://baike.baidu.com/view/836474.htm?fr=aladdin&quot;&gt;左值&lt;/a&gt;,但我们可以在等式右边加入左值，也就是说可以写成这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*a = *a + *b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了不改变指针的值，还需要用点小技巧，就是用“,”来分割语句，可以写成下面这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = (*a = *a + *b , a )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为用“,”分割的语句，语句的返回值是最后一个子语句，这里就是a。现在应该明白了吧！那本题的一种解法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = (*a = *a + *b , a);
    b = (*b = *a - *b , b); //*b = *a + *b - *b = *a 
    a = (*a = *a - *b , a); //*a = *a + *b - *a = *b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用乘除法和异或运算来实现，大同小异，这里不再给出。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Leetcode TwoSum</title>
   <link href="http://hombo.wang/leetcode/2014/10/05/Two-Sum"/>
   <updated>2014-10-05T00:00:00+08:00</updated>
   <id>http://hombo.wang/leetcode/2014/10/05/Two-Sum</id>
   <content type="html">&lt;p&gt;这是一道基本的数组查找问题，需要O(n)的时间复杂度才能AC，有两种解答方法，一种是用排序和双指针，另一种是用hash表，下面具体来说。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given an array of integers, find two numbers such that they add up to a specific target number.&lt;/p&gt;

&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;hash表解法:&lt;/h2&gt;

&lt;p&gt;这种解法很简单，就是建立 &amp;lt;numbers[i],i&amp;gt; 这一对索引，遍历一遍numbers， 然后用target-numbers[i] 去找hash 表 ，如果存在 ，取出i，搞定!&lt;/p&gt;

&lt;p&gt;时间复杂度是O(n), 空间复杂度是hash表的大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target){
    unordered_map&amp;lt;int, int&amp;gt; hash;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; numbers.size(); i++{
        int numberToFind = target - numbers[i];
        if (hash.find(numberToFind) != hash.end()) {
            result.push_back(hash[numberToFind] + 1);
            result.push_back(i + 1);            
            return result;
        }
        hash[numbers[i]] = i;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;快速排序+双指针解法：&lt;/h2&gt;

&lt;p&gt;先将numbers数组从小到大进行快速排序，然后一个index i 从numbers[0]开始，另一个index j 从numbers的结束开始，往中间靠拢。在这个靠拢过程中，如果numbers[i] + numbers[j] &amp;lt; target 说明加和的值还不够，需要继续增加，那只能增大i了（因为numbers从小到大排序），如果numbers[i] + numbers[j] &amp;gt; target 说明加和的值大了，需要减小点，那也只能减小j了，如果numbers[i] + numbers[j] == target , 那说明我们找到了答案。由于题目要求给出原来数组中的位置，并且第一个数位置为1（而不是0），因此我们需要一个额外的数组暂存原来的数组，然后找到在原始数组中的位置。&lt;/p&gt;

&lt;p&gt;算法的时间复杂度是：快排O(nlogn) + 双指针O(n) + 找位置 O(n)  = O(nlogn) ，由于用到了一个额外数组，空间复杂度是O(n)。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target) {
        vector&amp;lt;int&amp;gt; result,tmp = numbers;
        int a = 0,b = 0;
        sort(tmp.begin(),tmp.end());
        int i = 0 ,j = tmp.size()-1;
        while(i&amp;lt;j){
            if(tmp[i]+tmp[j] == target) break;
            else if (tmp[i]+tmp[j] &amp;gt; target) --j;
            else ++i;
        }
        for(int w = 0 ; (!a||!b)&amp;amp;&amp;amp;w &amp;lt; numbers.size();++w){
            if((!a)&amp;amp;&amp;amp;numbers[w] == tmp[i]) a = w+1;
            else if(numbers[w] == tmp[j]) b = w+1;
        }
        result.push_back(a&amp;lt;b?a:b);
        result.push_back(a&amp;gt;b?a:b);
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 
</feed>