<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Hombo's Blog</title>
 <link href="http://hombo.wang/" rel="self"/>
 <link href="http://hombo.wang"/>
 <updated>2014-10-06T20:41:10+08:00</updated>
 <id>http://hombo.wang</id>
 <author>
   <name>Hombo Wang</name>
   <email></email>
 </author>

 
 <entry>
   <title>Leetcode Surrounded Regions</title>
   <link href="http://hombo.wang/leetcode/2014/10/06/surrounded-regions"/>
   <updated>2014-10-06T00:00:00+08:00</updated>
   <id>http://hombo.wang/leetcode/2014/10/06/surrounded-regions</id>
   <content type="html">&lt;p&gt;这是一道图搜索题，关键在于用DFS或BFS搜索时，处理好边界条件和其他限制条件，例如遇到&lt;code&gt;‘X’&lt;/code&gt;就停止这条路的搜索。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a 2D board containing &lt;code&gt;&#39;X&#39;&lt;/code&gt; and &lt;code&gt;&#39;O&#39;&lt;/code&gt;, capture all regions surrounded by &lt;code&gt;&#39;X&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A region is captured by flipping all ‘O’s into &lt;code&gt;&#39;X&#39;&lt;/code&gt;s in that surrounded region.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X O O X
X X O X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the board should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X X X X
X X X X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;题目的意思是说把这个2D board中完全被&lt;code&gt;&#39;X&#39;&lt;/code&gt;包住的&lt;code&gt;&#39;O&#39;&lt;/code&gt;的区域全部替换为&lt;code&gt;&#39;X&#39;&lt;/code&gt;，就像上面给出的一个例子，内部的三个&lt;code&gt;&#39;O&#39;&lt;/code&gt;被替换了，而边界的&lt;code&gt;&#39;O&#39;&lt;/code&gt;由于没有被包住而不需要替换。&lt;/p&gt;

&lt;p&gt;这道题其实就是一个图的搜索问题，可以把这个2D board看成由几个连通子图构成的，连通子图由全&lt;code&gt;O&lt;/code&gt;或者全&lt;code&gt;X&lt;/code&gt;构成&lt;/p&gt;

&lt;p&gt;搜索的过程是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 从头开始遍历这个2D board， 如果遇到一个`O` ，就从这个`O` 开始进行DFS或者BFS遍历它的连通子图，边界条件就是遇到`X`或者board的边界停止。我们知道连通子图之间是没有路径的，这样就不会对其他子图产生影响。

2. 在遍历的过程中，不断判断是否有`O`在board的边界，如果有，就标记这个子图为`需要替换为‘X’的子图`，在遍历结束后将这个子图中的元素全部替换成`X`。子图的存储可以用一个vector实现。

3. 然后继续在board中往后找没有被访问过的`O`，继续上面的过程，直至结束。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了题目的要求。&lt;/p&gt;

&lt;p&gt;这里用&lt;code&gt;DFS&lt;/code&gt;和&lt;code&gt;BFS&lt;/code&gt;都行，时间复杂度是O(n)，由于要借助一定空间来做标记和存储子图，所以空间复杂度是O(n)&lt;/p&gt;

&lt;p&gt;这个只给出用&lt;code&gt;DFS&lt;/code&gt;AC的代码，&lt;code&gt;BFS&lt;/code&gt;的实现方式把stack换成queue就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) {
        if(board.size()&amp;lt;=2||board[0].size()&amp;lt;=2) return;
        stack&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; s; //DFS stack
        int xsize = board.size(), ysize = board[0].size();
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; record(xsize,vector&amp;lt;bool&amp;gt;(ysize,false)); // 访问标记
        vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; canlist; //存储连通子图
        bool can = true;
        for(int i = 1 ; i &amp;lt; xsize-1 ; ++i){
            for(int j = 1 ; j &amp;lt; ysize-1 ; ++j){ //遍历所有未访问的‘O’
                if(board[i][j] == &#39;O&#39;&amp;amp;&amp;amp;!record[i][j]){
                    can = true;
                    s.push(make_pair(i,j));
                    canlist.push_back(make_pair(i,j));
                    record[i][j] = true;
                    while(!s.empty()){ //DFS
                        pair&amp;lt;int,int&amp;gt; p = s.top();
                        s.pop();
                        if(can&amp;amp;&amp;amp;(p.first==0||p.first==xsize-1||p.second==0||p.second==ysize-1))
                            can = false;
                        if((p.first&amp;gt;0)&amp;amp;&amp;amp;board[p.first-1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first-1][p.second]){
                            s.push(make_pair(p.first-1,p.second));
                            record[p.first-1][p.second] = true;
                            canlist.push_back(make_pair(p.first-1,p.second));
                        }
                        if((p.first&amp;lt;xsize-1)&amp;amp;&amp;amp;board[p.first+1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first+1][p.second]){
                            s.push(make_pair(p.first+1,p.second));
                            record[p.first+1][p.second] = true;
                            canlist.push_back(make_pair(p.first+1,p.second));
                        }
                        if((p.second&amp;gt;0)&amp;amp;&amp;amp;board[p.first][p.second-1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second-1]){
                            s.push(make_pair(p.first,p.second-1));
                            record[p.first][p.second-1] = true;
                            canlist.push_back(make_pair(p.first,p.second-1));
                        }
                        if((p.second&amp;lt;ysize-1)&amp;amp;&amp;amp;board[p.first][p.second+1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second+1]){
                            s.push(make_pair(p.first,p.second+1));
                            record[p.first][p.second+1] = true;
                            canlist.push_back(make_pair(p.first,p.second+1));
                        }
                    }
                    if(can){ //改变连通子图中的&#39;O&#39;为‘X’
                        for(int w = 0 ; w &amp;lt; canlist.size() ; ++w)
                            board[canlist[w].first][canlist[w].second] = &#39;X&#39;;
                    }
                    canlist.clear();
                }
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Sum Root to Leaf Numbers</title>
   <link href="http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers"/>
   <updated>2014-10-06T00:00:00+08:00</updated>
   <id>http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers</id>
   <content type="html">&lt;p&gt;leetcode上比较简单的一道题了，一个二叉树，结点用0～9的数表示，让你求所有从根到叶的连起来的数的加和。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a binary tree containing digits from &lt;code&gt;0-9&lt;/code&gt; only, each &lt;code&gt;root-to-leaf&lt;/code&gt; path could represent a number.&lt;/p&gt;

&lt;p&gt;An example is the root-to-leaf path &lt;code&gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt; which represents the number &lt;code&gt;123&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Find the total sum of all &lt;code&gt;root-to-leaf&lt;/code&gt; numbers.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
   / \
  2   3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;2&lt;/code&gt; represents the number &lt;code&gt;12&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;3&lt;/code&gt; represents the number &lt;code&gt;13&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return the &lt;code&gt;sum = 12 + 13 = 25&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;要想得到全部的root到leaf的值的总和，我们需要用一个全局的变量sum来保存加和的结果，并且需要父结点向儿子结点传递当前&lt;code&gt;前缀值&lt;/code&gt;，做到这两点，用一次DFS就行了，只需要对树进行一次遍历即可，如果遍历到叶结点，就将这条路径值加到sum。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sum;
    int sumNumbers(TreeNode *root) {
        sum = 0;
        if(root == NULL) return 0;
        travel(root,0);
        return sum;
    }
    void travel(TreeNode *node,int pre){
        if(node-&amp;gt;left == NULL &amp;amp;&amp;amp; node-&amp;gt;right == NULL)
            sum += pre*10+node-&amp;gt;val;
        else{
            if(node-&amp;gt;left != NULL) travel(node-&amp;gt;left,pre*10+node-&amp;gt;val);
            if(node-&amp;gt;right != NULL) travel(node-&amp;gt;right,pre*10+node-&amp;gt;val);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>无私分享一个翻墙的好方法</title>
   <link href="http://hombo.wang/hosts/2014/10/06/hosts"/>
   <updated>2014-10-06T00:00:00+08:00</updated>
   <id>http://hombo.wang/hosts/2014/10/06/hosts</id>
   <content type="html">&lt;p&gt;这个翻墙方法是我认为最好的一种，可以随意上facebook，Twitter，Google+等被墙的网站，而且速度非常快，简单易操作。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;方法就是：点击此&lt;a href=&quot;http://pan.baidu.com/s/1bnq4dKr&quot;&gt;hosts&lt;/a&gt;文件，然后下载，把下载的hosts文件替换系统的hosts，不同系统更换hosts的方法不同，下面列出不同系统的hosts文件位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac OS X : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/private/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;最好在shell下用vi来修改，需要用户权限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows XP/Windows 7/Windows 8 : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C:\WINDOWS\system32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;需要用户权限，建议用vi+sudo来修改&lt;/p&gt;

&lt;p&gt;替换了系统的hosts文件后就可以用你的浏览器翻墙了！&lt;/p&gt;

&lt;h3 id=&quot;https&quot;&gt;注意！！上国外的网站时一定要记得在网站前面加&lt;code&gt;https://&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;例如：https://www.facebook.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个hosts文件我会定期更新，敬请关注！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>swap两个int指针指向的数</title>
   <link href="http://hombo.wang/algorithm/2014/10/05/swap-two-int"/>
   <updated>2014-10-05T00:00:00+08:00</updated>
   <id>http://hombo.wang/algorithm/2014/10/05/swap-two-int</id>
   <content type="html">&lt;p&gt;这是一道最近的面试题，感谢斌哥的奉献！
题目是： 填写下面的函数，实现a和b指针指向的两个数的交换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    *a = ________ ;
    *b = ________ ;
    *a = ________ ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;我们知道对于两个数a,b的交换，如果不借助其他变量，也是可以实现的，方法有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用加减法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用加减法的 &lt;code&gt;交换律&lt;/code&gt; 和 &lt;code&gt;结合律&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a + b;
    b = a - b; //b = a + b - b = a 
    a = a - b; //a = a + b - a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;用乘除法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，这个方法需要满足 &lt;code&gt;a*b != 0&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a * b;
    b = a / b; //b = a * b / b = a 
    a = a / b; //a = a * b / a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这个方法用到了乘除法的 &lt;code&gt;分配率&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用异或运算：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用异或的性质: &lt;code&gt;交换律&lt;/code&gt; , &lt;code&gt;结合律&lt;/code&gt;  , &lt;code&gt;a ^ a = 0&lt;/code&gt; , &lt;code&gt;0 ^ a = a&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a ^ b;
    b = a ^ b; //b = a ^ b ^ b = a ^ 0 = a 
    a = a ^ b; //a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而本题给的是指针，而且等式左边都是指针，也就是说没办法直接改变指针指向的内存位置的值，那怎么办呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法:&lt;/h2&gt;

&lt;p&gt;虽然等式左边没有给出&lt;a href=&quot;http://baike.baidu.com/view/836474.htm?fr=aladdin&quot;&gt;左值&lt;/a&gt;,但我们可以在等式右边加入左值，也就是说可以写成这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*a = *a + *b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了不改变指针的值，还需要用点小技巧，就是用“,”来分割语句，可以写成下面这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = (*a = *a + *b , a )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为用“,”分割的语句，语句的返回值是最后一个子语句，这里就是a。现在应该明白了吧！那本题的一种解法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = (*a = *a + *b , a);
    b = (*b = *a - *b , b); //*b = *a + *b - *b = *a 
    a = (*a = *a - *b , a); //*a = *a + *b - *a = *b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用乘除法和异或运算来实现，大同小异，这里不再给出。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Leetcode TwoSum</title>
   <link href="http://hombo.wang/leetcode/2014/10/05/Two-Sum"/>
   <updated>2014-10-05T00:00:00+08:00</updated>
   <id>http://hombo.wang/leetcode/2014/10/05/Two-Sum</id>
   <content type="html">&lt;p&gt;这是一道基本的数组查找问题，需要O(n)的时间复杂度才能AC，有两种解答方法，一种是用排序和双指针，另一种是用hash表，下面具体来说。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given an array of integers, find two numbers such that they add up to a specific target number.&lt;/p&gt;

&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;hash表解法:&lt;/h2&gt;

&lt;p&gt;这种解法很简单，就是建立 &amp;lt;numbers[i],i&amp;gt; 这一对索引，遍历一遍numbers， 然后用target-numbers[i] 去找hash 表 ，如果存在 ，取出i，搞定!&lt;/p&gt;

&lt;p&gt;时间复杂度是O(n), 空间复杂度是hash表的大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target){
    unordered_map&amp;lt;int, int&amp;gt; hash;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; numbers.size(); i++{
        int numberToFind = target - numbers[i];
        if (hash.find(numberToFind) != hash.end()) {
            result.push_back(hash[numberToFind] + 1);
            result.push_back(i + 1);            
            return result;
        }
        hash[numbers[i]] = i;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;快速排序+双指针解法：&lt;/h2&gt;

&lt;p&gt;先将numbers数组从小到大进行快速排序，然后一个index i 从numbers[0]开始，另一个index j 从numbers的结束开始，往中间靠拢。在这个靠拢过程中，如果numbers[i] + numbers[j] &amp;lt; target 说明加和的值还不够，需要继续增加，那只能增大i了（因为numbers从小到大排序），如果numbers[i] + numbers[j] &amp;gt; target 说明加和的值大了，需要减小点，那也只能减小j了，如果numbers[i] + numbers[j] == target , 那说明我们找到了答案。由于题目要求给出原来数组中的位置，并且第一个数位置为1（而不是0），因此我们需要一个额外的数组暂存原来的数组，然后找到在原始数组中的位置。&lt;/p&gt;

&lt;p&gt;算法的时间复杂度是：快排O(nlogn) + 双指针O(n) + 找位置 O(n)  = O(nlogn) ，由于用到了一个额外数组，空间复杂度是O(n)。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target) {
        vector&amp;lt;int&amp;gt; result,tmp = numbers;
        int a = 0,b = 0;
        sort(tmp.begin(),tmp.end());
        int i = 0 ,j = tmp.size()-1;
        while(i&amp;lt;j){
            if(tmp[i]+tmp[j] == target) break;
            else if (tmp[i]+tmp[j] &amp;gt; target) --j;
            else ++i;
        }
        for(int w = 0 ; (!a||!b)&amp;amp;&amp;amp;w &amp;lt; numbers.size();++w){
            if((!a)&amp;amp;&amp;amp;numbers[w] == tmp[i]) a = w+1;
            else if(numbers[w] == tmp[j]) b = w+1;
        }
        result.push_back(a&amp;lt;b?a:b);
        result.push_back(a&amp;gt;b?a:b);
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 
</feed>