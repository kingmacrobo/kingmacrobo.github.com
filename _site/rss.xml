<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Hombo's Blog</title>
        <description>Hombo's Blog - Hombo Wang</description>
        <link>http://hombo.wang</link>
        <link>http://hombo.wang</link>
        <lastBuildDate>2014-12-26T16:32:06+08:00</lastBuildDate>
        <pubDate>2014-12-26T16:32:06+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>RoundedNetworkImageView</title>
                <description>&lt;p&gt;将Volley的NetworkImageView的方形显示图片改为圆形显示，方法非常好，在此记录一下代码，方便自己和其他人今后使用！&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;imageviewondrawgetcroppedbitmap&quot;&gt;将方形改成圆形的核心思想是重写ImageView的onDraw和getCroppedBitmap两个方法。&lt;/h4&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  RoundedNetworkImageView
 
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Shader;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
 
import com.android.volley.toolbox.NetworkImageView;
 
 
public class RoundedNetworkImageView extends NetworkImageView {
    private int borderColor = 0xffffffff;
    private int borderWidth = 10;
 
    public RoundedNetworkImageView(Context context) {
        super(context);
    }
 
    public RoundedNetworkImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
 
    public RoundedNetworkImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }
 
    public void setBorderColor(int resourceID) {
        borderColor = resourceID;
    }
 
    public void setBorderWidth(int border) {
        borderWidth = border;
    }
 
    public int getBorderWidth() {
        return borderWidth;
    }
 
    @Override
    protected void onDraw(Canvas canvas) {
        Drawable drawable = getDrawable();
 
        if (drawable == null || getWidth() == 0 || getHeight() == 0)
            return;
 
        Bitmap b = ((BitmapDrawable) drawable).getBitmap();
        if (b != null) {
            Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888, true);
 
            int radius = (getWidth() &amp;lt; getHeight()) ? getWidth() / 2 : getHeight() / 2;
 
            Bitmap roundBitmap = getCroppedBitmap(bitmap, radius);
            canvas.drawBitmap(roundBitmap, 0, 0, null);
        }
    }
 
    public Bitmap getCroppedBitmap(Bitmap bmp, int radius) {
        Bitmap scaledBmp = Bitmap.createScaledBitmap(bmp, radius * 2, radius * 2, false);
        Bitmap output = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(output);
 
        final Paint paint = new Paint();
 
        paint.setAntiAlias(true);
        paint.setFilterBitmap(true);
        paint.setDither(true);
        canvas.drawARGB(0, 0, 0, 0);
 
        // Draws a circle to create the border
        paint.setColor(borderColor);
        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, paint);
 
        // Draws the image subtracting the border width
        BitmapShader s = new BitmapShader(scaledBmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
        paint.setShader(s);
        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius - borderWidth - 0.5f, paint);
 
        return output;
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/android/2014/12/26/RoundedNetWorkImageView</link>
                <guid>http://hombo.wang/android/2014/12/26/RoundedNetWorkImageView</guid>
                <pubDate>2014-12-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode Unique Binary Search Trees</title>
                <description>&lt;p&gt;这道题是一道关于BST树的问题，也就是二叉排序树，题目的意思是给出n个结点，每个结点的值从1到n，问这n个结点组成的二叉排序树有多少种？题目其实不难，用dp可以在O(n^2)下解决，但这里有一个更快的的方法——卡特兰数（Catalan number）。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1         3     3      2      1
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;这道题是一道组合问题，如果测试数据足够强，复杂度不能超过O(n^2)才能AC，如果采用模拟二叉排序树的建立过程，即采用递归的方法将会超时。&lt;/p&gt;

&lt;p&gt;如果我们仔细观察规律，可以发现这个问题可以用dp来解，假设现在n=0,n=1,n=2,….,n=k的解已经求出来，那么对于k+1来说，它的解是什么？我们可以想一下二叉排序数的性质，一个结点左边的儿子分支肯定都小于这个结点，右边的儿子分支肯定都大于这个结点，我们可以把n=k+1的结果看作下面这样组成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1         2          3          4                k         k+1
\        / \        / \        / \     .....   /   \      /
2~k+1   1  3~k+1  1~2 4~k+1  1~3 5~k+1      1~k-1  k+1  1~k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把儿子子树看成一个新的相同的问题，如果儿子子树有m个结点，那这个子树的组合情况就是n=m的解，由此，我们可以得到一个递推公式：&lt;/p&gt;

&lt;p&gt;dp[n] = Σ dp[i-1]*dp[n-i]  (i = 1,2,3,….,n)&lt;/p&gt;

&lt;p&gt;为了能让递推顺利，我们假设dp[0] = 1 .&lt;/p&gt;

&lt;p&gt;如果上面的解递推公式理解了，那就可以很容易的写出代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int numTrees(int n) {
        vector&amp;lt;int&amp;gt; dp(n+1,0);
        if(n&amp;lt;=1) return n;
        dp[0] = 1;
        for(int i = 1 ; i &amp;lt;= n ; ++i){
            for(int j = 1 ; j &amp;lt;=i ; ++j) dp[i] += dp[j-1]*dp[i-j];
        }
        return dp[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中可以看出时间复杂度是O(n^2),由于用到了vector&lt;int&gt;来存储dp，空间复杂度就是O(n)；&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;如果到这里就认为这是最佳解法，你就错了！其实还有O(n)的解法！！那就是用&lt;a href=&quot;http://en.wikipedia.org/wiki/Catalan_number&quot;&gt;卡特兰数&lt;/a&gt;的变换公式。&lt;/p&gt;

&lt;p&gt;我这里简单介绍一下卡特兰数：&lt;/p&gt;

&lt;p&gt;卡特兰数是满足下面递推公式的数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/2/f/1/2f17435a71394ce667ab694b27341560.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以用下面的递推公式表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/8/a/4/8a49332e4a46b3a2c7accec81160f5e3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一个递推公式和我们这道题的dp的递推一模一样，而第二个是卡特兰数的变换递推公式，如果我们用这个公式，显然更简单，而且可以在O(n)时间和O(1)空间下解决问题。代码很简单，就是用第二个递推公式，从n＝1开始，求到n。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int numTrees(int n) {
        long long ans = 1;
        for(int i = 1; i &amp;lt;= n; ++ i)
            ans  = ans * 2 * (2 * i - 1) / (i + 1);
        return (int) ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/10/unique-binary-search-tree</link>
                <guid>http://hombo.wang/leetcode/2014/10/10/unique-binary-search-tree</guid>
                <pubDate>2014-10-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode Surrounded Regions</title>
                <description>&lt;p&gt;这是一道图搜索题，关键在于用DFS或BFS搜索时，处理好边界条件和其他限制条件，例如遇到&lt;code&gt;‘X’&lt;/code&gt;就停止这条路的搜索。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a 2D board containing &lt;code&gt;&#39;X&#39;&lt;/code&gt; and &lt;code&gt;&#39;O&#39;&lt;/code&gt;, capture all regions surrounded by &lt;code&gt;&#39;X&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A region is captured by flipping all ‘O’s into &lt;code&gt;&#39;X&#39;&lt;/code&gt;s in that surrounded region.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X O O X
X X O X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the board should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X X X X
X X X X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;题目的意思是说把这个2D board中完全被&lt;code&gt;&#39;X&#39;&lt;/code&gt;包住的&lt;code&gt;&#39;O&#39;&lt;/code&gt;的区域全部替换为&lt;code&gt;&#39;X&#39;&lt;/code&gt;，就像上面给出的一个例子，内部的三个&lt;code&gt;&#39;O&#39;&lt;/code&gt;被替换了，而边界的&lt;code&gt;&#39;O&#39;&lt;/code&gt;由于没有被包住而不需要替换。&lt;/p&gt;

&lt;p&gt;这道题其实就是一个图的搜索问题，可以把这个2D board看成由几个连通子图构成的，连通子图由全&lt;code&gt;O&lt;/code&gt;或者全&lt;code&gt;X&lt;/code&gt;构成&lt;/p&gt;

&lt;p&gt;搜索的过程是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 从头开始遍历这个2D board， 如果遇到一个`O` ，就从这个`O` 开始进行DFS或者BFS遍历它的连通子图，边界条件就是遇到`X`或者board的边界停止。我们知道连通子图之间是没有路径的，这样就不会对其他子图产生影响。

2. 在遍历的过程中，不断判断是否有`O`在board的边界，如果有，就标记这个子图为`需要替换为‘X’的子图`，在遍历结束后将这个子图中的元素全部替换成`X`。子图的存储可以用一个vector实现。

3. 然后继续在board中往后找没有被访问过的`O`，继续上面的过程，直至结束。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了题目的要求。&lt;/p&gt;

&lt;p&gt;这里用&lt;code&gt;DFS&lt;/code&gt;和&lt;code&gt;BFS&lt;/code&gt;都行，时间复杂度是O(n)，由于要借助一定空间来做标记和存储子图，所以空间复杂度是O(n)&lt;/p&gt;

&lt;p&gt;这个只给出用&lt;code&gt;DFS&lt;/code&gt;AC的代码，&lt;code&gt;BFS&lt;/code&gt;的实现方式把stack换成queue就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) {
        if(board.size()&amp;lt;=2||board[0].size()&amp;lt;=2) return;
        stack&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; s; //DFS stack
        int xsize = board.size(), ysize = board[0].size();
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; record(xsize,vector&amp;lt;bool&amp;gt;(ysize,false)); // 访问标记
        vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; canlist; //存储连通子图
        bool can = true;
        for(int i = 1 ; i &amp;lt; xsize-1 ; ++i){
            for(int j = 1 ; j &amp;lt; ysize-1 ; ++j){ //遍历所有未访问的‘O’
                if(board[i][j] == &#39;O&#39;&amp;amp;&amp;amp;!record[i][j]){
                    can = true;
                    s.push(make_pair(i,j));
                    canlist.push_back(make_pair(i,j));
                    record[i][j] = true;
                    while(!s.empty()){ //DFS
                        pair&amp;lt;int,int&amp;gt; p = s.top();
                        s.pop();
                        if(can&amp;amp;&amp;amp;(p.first==0||p.first==xsize-1||p.second==0||p.second==ysize-1))
                            can = false;
                        if((p.first&amp;gt;0)&amp;amp;&amp;amp;board[p.first-1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first-1][p.second]){
                            s.push(make_pair(p.first-1,p.second));
                            record[p.first-1][p.second] = true;
                            canlist.push_back(make_pair(p.first-1,p.second));
                        }
                        if((p.first&amp;lt;xsize-1)&amp;amp;&amp;amp;board[p.first+1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first+1][p.second]){
                            s.push(make_pair(p.first+1,p.second));
                            record[p.first+1][p.second] = true;
                            canlist.push_back(make_pair(p.first+1,p.second));
                        }
                        if((p.second&amp;gt;0)&amp;amp;&amp;amp;board[p.first][p.second-1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second-1]){
                            s.push(make_pair(p.first,p.second-1));
                            record[p.first][p.second-1] = true;
                            canlist.push_back(make_pair(p.first,p.second-1));
                        }
                        if((p.second&amp;lt;ysize-1)&amp;amp;&amp;amp;board[p.first][p.second+1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second+1]){
                            s.push(make_pair(p.first,p.second+1));
                            record[p.first][p.second+1] = true;
                            canlist.push_back(make_pair(p.first,p.second+1));
                        }
                    }
                    if(can){ //改变连通子图中的&#39;O&#39;为‘X’
                        for(int w = 0 ; w &amp;lt; canlist.size() ; ++w)
                            board[canlist[w].first][canlist[w].second] = &#39;X&#39;;
                    }
                    canlist.clear();
                }
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/surrounded-regions</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/surrounded-regions</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Sum Root to Leaf Numbers</title>
                <description>&lt;p&gt;leetcode上比较简单的一道题了，一个二叉树，结点用0～9的数表示，让你求所有从根到叶的连起来的数的加和。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a binary tree containing digits from &lt;code&gt;0-9&lt;/code&gt; only, each &lt;code&gt;root-to-leaf&lt;/code&gt; path could represent a number.&lt;/p&gt;

&lt;p&gt;An example is the root-to-leaf path &lt;code&gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt; which represents the number &lt;code&gt;123&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Find the total sum of all &lt;code&gt;root-to-leaf&lt;/code&gt; numbers.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
   / \
  2   3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;2&lt;/code&gt; represents the number &lt;code&gt;12&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;3&lt;/code&gt; represents the number &lt;code&gt;13&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return the &lt;code&gt;sum = 12 + 13 = 25&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;要想得到全部的root到leaf的值的总和，我们需要用一个全局的变量sum来保存加和的结果，并且需要父结点向儿子结点传递当前&lt;code&gt;前缀值&lt;/code&gt;，做到这两点，用一次DFS就行了，只需要对树进行一次遍历即可，如果遍历到叶结点，就将这条路径值加到sum。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sum;
    int sumNumbers(TreeNode *root) {
        sum = 0;
        if(root == NULL) return 0;
        travel(root,0);
        return sum;
    }
    void travel(TreeNode *node,int pre){
        if(node-&amp;gt;left == NULL &amp;amp;&amp;amp; node-&amp;gt;right == NULL)
            sum += pre*10+node-&amp;gt;val;
        else{
            if(node-&amp;gt;left != NULL) travel(node-&amp;gt;left,pre*10+node-&amp;gt;val);
            if(node-&amp;gt;right != NULL) travel(node-&amp;gt;right,pre*10+node-&amp;gt;val);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Longest Consecutive Sequence</title>
                <description>&lt;p&gt;Given an unsorted array of integers, find the length of the longest consecutive elements sequence. For example,&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;[100, 4, 200, 1, 3, 2]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;The longest consecutive elements sequence is &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;. Return its length: &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your algorithm should run in &lt;code&gt;O(n)&lt;/code&gt; complexity.&lt;/p&gt;

&lt;p&gt;此题可以用hashmap在&lt;code&gt;O(n)&lt;/code&gt; 时间复杂度解决。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;一看是无需数组，又要求&lt;code&gt;O(n)&lt;/code&gt;复杂度实现，很自然的可以想到用hashmap。&lt;/p&gt;

&lt;p&gt;具体方法就是将数组全部hash了，然后在对数组的每个元素进行一边查找，&lt;/p&gt;

&lt;p&gt;例如对于数组的第i个数，我们不断判断&lt;code&gt;num[i]+1&lt;/code&gt;是否在hash表里，如果在说明数组存在比&lt;code&gt;num[i]&lt;/code&gt;大1的数，然后继续判断&lt;code&gt;num[i]+2&lt;/code&gt;……直到&lt;code&gt;num[i]+k&lt;/code&gt;不再hash表里位置，在这个过程中需要记录长度。&lt;/p&gt;

&lt;p&gt;只用上面的算法不能保证是&lt;code&gt;O(n)&lt;/code&gt;的，看下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数组是 `[7,6,5,4,3]`

查找过程是： 

7: `7`
6: `6,7`
5: `5,6,7`
4: `4,5,6,7`
3: `3,4,5,6,7`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然复杂度最坏未为&lt;code&gt;O(n^2)&lt;/code&gt;, 了保证算法是&lt;code&gt;O(n)&lt;/code&gt;的，我们要用一些小技巧，让数组中已经被判断过的数不再去判断，其实很简单，就是加一个标示，表示这个数是否在前面的数里面判断过了，我们还可以将每次判断出来的长度存在这次判断最开始的那个数的hashmap中，这样下次如果加到这个数的时候，可以直接用这个长度值，而不需要往后遍历了，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5: 5,6,7   把长度3存在hashmap : &amp;lt;5,3&amp;gt;
4: 4,5,6,7 当4 上加到5的时候，可以从&amp;lt;5,3&amp;gt;直到5后面连续的长度是3，就不用再遍历了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以保证算法是O(n)的了，空间复杂度是hash表大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int longestConsecutive(vector&amp;lt;int&amp;gt; &amp;amp;num) {
        unordered_map&amp;lt;int,int&amp;gt; hash;
        int max = 0,count,j;
        unordered_map&amp;lt;int,int&amp;gt;::iterator it;
        for(int i = 0 ; i &amp;lt; num.size(); ++i) hash.insert({num[i],-1});
        for(int i = 0 ; i &amp;lt; num.size(); ++i){
            if(hash.find(num[i])-&amp;gt;second!=-1) continue;
            count = 1;
            j = num[i]+1;
            while((it=hash.find(j++))!=hash.end()){
                if(it-&amp;gt;second &amp;gt; 0){
                    count += it-&amp;gt;second;
                    break;
                }
                it-&amp;gt;second = 0;
                ++count;
            }
            hash.find(num[i])-&amp;gt;second = count;
            if(max &amp;lt; count) max = count;
        }
        return max;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，还有一种算法是同时从num[i]的两边不断判断，并标记已经判断过的的数，这种方法可以省去一些长度的记录。&lt;/p&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/longest-consecutive-sequence</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/longest-consecutive-sequence</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>无私分享一个翻墙的好方法</title>
                <description>&lt;p&gt;这个翻墙方法是我认为最好的一种，可以随意上facebook，Twitter，Google+等被墙的网站，而且速度非常快，简单易操作。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;方法就是：点击此&lt;a href=&quot;http://pan.baidu.com/s/1hqDuVHE&quot;&gt;hosts&lt;/a&gt;文件，然后下载，把下载的hosts文件替换系统的hosts，不同系统更换hosts的方法不同，下面列出不同系统的hosts文件位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac OS X : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/private/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;最好在shell下用vi来修改，需要用户权限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows XP/Windows 7/Windows 8 : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C:\WINDOWS\system32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;需要用户权限，建议用vi+sudo来修改&lt;/p&gt;

&lt;p&gt;替换了系统的hosts文件后就可以用你的浏览器翻墙了！&lt;/p&gt;

&lt;h3 id=&quot;https&quot;&gt;注意！！上国外的网站时一定要记得在网站前面加&lt;code&gt;https://&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;例如：https://www.facebook.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个hosts文件我会定期更新，敬请关注！&lt;/p&gt;
</description>
                <link>http://hombo.wang/hosts/2014/10/06/hosts</link>
                <guid>http://hombo.wang/hosts/2014/10/06/hosts</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>swap两个int指针指向的数</title>
                <description>&lt;p&gt;这是一道最近的面试题，感谢斌哥的奉献！
题目是： 填写下面的函数，实现a和b指针指向的两个数的交换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = ________ ;
    b = ________ ;
    a = ________ ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;我们知道对于两个数a,b的交换，如果不借助其他变量，也是可以实现的，方法有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用加减法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用加减法的 &lt;code&gt;交换律&lt;/code&gt; 和 &lt;code&gt;结合律&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a + b;
    b = a - b; //b = a + b - b = a 
    a = a - b; //a = a + b - a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;用乘除法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，这个方法需要满足 &lt;code&gt;a*b != 0&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a * b;
    b = a / b; //b = a * b / b = a 
    a = a / b; //a = a * b / a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这个方法用到了乘除法的 &lt;code&gt;分配率&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用异或运算：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用异或的性质: &lt;code&gt;交换律&lt;/code&gt; , &lt;code&gt;结合律&lt;/code&gt;  , &lt;code&gt;a ^ a = 0&lt;/code&gt; , &lt;code&gt;0 ^ a = a&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a ^ b;
    b = a ^ b; //b = a ^ b ^ b = a ^ 0 = a 
    a = a ^ b; //a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而本题给的是指针，而且等式左边都是指针，也就是说没办法直接改变指针指向的内存位置的值，那怎么办呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法:&lt;/h2&gt;

&lt;p&gt;虽然等式左边没有给出&lt;a href=&quot;http://baike.baidu.com/view/836474.htm?fr=aladdin&quot;&gt;左值&lt;/a&gt;,但我们可以在等式右边加入左值，也就是说可以写成这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*a = *a + *b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了不改变指针的值，还需要用点小技巧，就是用“,”来分割语句，可以写成下面这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = (*a = *a + *b , a )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为用“,”分割的语句，语句的返回值是最后一个子语句，这里就是a。现在应该明白了吧！那本题的一种解法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = (*a = *a + *b , a);
    b = (*b = *a - *b , b); //*b = *a + *b - *b = *a 
    a = (*a = *a - *b , a); //*a = *a + *b - *a = *b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用乘除法和异或运算来实现，大同小异，这里不再给出。&lt;/p&gt;
</description>
                <link>http://hombo.wang/algorithm/2014/10/05/swap-two-int</link>
                <guid>http://hombo.wang/algorithm/2014/10/05/swap-two-int</guid>
                <pubDate>2014-10-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode TwoSum</title>
                <description>&lt;p&gt;这是一道基本的数组查找问题，需要O(n)的时间复杂度才能AC，有两种解答方法，一种是用排序和双指针，另一种是用hash表，下面具体来说。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given an array of integers, find two numbers such that they add up to a specific target number.&lt;/p&gt;

&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;hash表解法:&lt;/h2&gt;

&lt;p&gt;这种解法很简单，就是建立 &amp;lt;numbers[i],i&amp;gt; 这一对索引，遍历一遍numbers， 然后用target-numbers[i] 去找hash 表 ，如果存在 ，取出i，搞定!&lt;/p&gt;

&lt;p&gt;时间复杂度是O(n), 空间复杂度是hash表的大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target){
    unordered_map&amp;lt;int, int&amp;gt; hash;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; numbers.size(); i++{
        int numberToFind = target - numbers[i];
        if (hash.find(numberToFind) != hash.end()) {
            result.push_back(hash[numberToFind] + 1);
            result.push_back(i + 1);            
            return result;
        }
        hash[numbers[i]] = i;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;快速排序+双指针解法：&lt;/h2&gt;

&lt;p&gt;先将numbers数组从小到大进行快速排序，然后一个index i 从numbers[0]开始，另一个index j 从numbers的结束开始，往中间靠拢。在这个靠拢过程中，如果numbers[i] + numbers[j] &amp;lt; target 说明加和的值还不够，需要继续增加，那只能增大i了（因为numbers从小到大排序），如果numbers[i] + numbers[j] &amp;gt; target 说明加和的值大了，需要减小点，那也只能减小j了，如果numbers[i] + numbers[j] == target , 那说明我们找到了答案。由于题目要求给出原来数组中的位置，并且第一个数位置为1（而不是0），因此我们需要一个额外的数组暂存原来的数组，然后找到在原始数组中的位置。&lt;/p&gt;

&lt;p&gt;算法的时间复杂度是：快排O(nlogn) + 双指针O(n) + 找位置 O(n)  = O(nlogn) ，由于用到了一个额外数组，空间复杂度是O(n)。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target) {
        vector&amp;lt;int&amp;gt; result,tmp = numbers;
        int a = 0,b = 0;
        sort(tmp.begin(),tmp.end());
        int i = 0 ,j = tmp.size()-1;
        while(i&amp;lt;j){
            if(tmp[i]+tmp[j] == target) break;
            else if (tmp[i]+tmp[j] &amp;gt; target) --j;
            else ++i;
        }
        for(int w = 0 ; (!a||!b)&amp;amp;&amp;amp;w &amp;lt; numbers.size();++w){
            if((!a)&amp;amp;&amp;amp;numbers[w] == tmp[i]) a = w+1;
            else if(numbers[w] == tmp[j]) b = w+1;
        }
        result.push_back(a&amp;lt;b?a:b);
        result.push_back(a&amp;gt;b?a:b);
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/05/Two-Sum</link>
                <guid>http://hombo.wang/leetcode/2014/10/05/Two-Sum</guid>
                <pubDate>2014-10-05T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
