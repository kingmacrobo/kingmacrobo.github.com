<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Hombo's Blog</title>
        <description>Hombo's Blog - Hombo Wang</description>
        <link>http://hombo.wang</link>
        <link>http://hombo.wang</link>
        <lastBuildDate>2014-10-05T15:59:40+08:00</lastBuildDate>
        <pubDate>2014-10-05T15:59:40+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>交叉编译OpenWrt上的Helloworld</title>
                <description>&lt;p&gt;终于编译完成了OpenWrt，并且成功交叉编译了Helloworld，并在Easy-Link的板子上运行。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;openwrt-sdk&quot;&gt;编译OpenWrt SDK&lt;/h1&gt;

&lt;p&gt;编译OpenWrt的过程，可参考&lt;a href=&quot;/openwrt/2014/08/10/compile_openwrt&quot;&gt;OpenWrt的编译&lt;/a&gt;。编译配置我勾选了&lt;code&gt;Advanced configuration option&lt;/code&gt;、&lt;code&gt;Build the OpenWrt SDK&lt;/code&gt;和&lt;code&gt;Build the OpenWrt based Toolchain&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;编译完成之后，交叉编译工具链在类似&lt;code&gt;staging_dir/toolchain-architecture_gcc-compilerver_uClibc-libcver/bin/&lt;/code&gt;目录。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;配置环境变量&lt;/h1&gt;

&lt;p&gt;主要配置以下环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=$PATH:(toolchain/bin目录)
export PATH

STAGING_DIR=(toolchain目录)
export STAGING_DIR
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;helloopenwrt&quot;&gt;交叉编译Helloopenwrt&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;helloopenwrt.c&lt;/code&gt;的源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int main() {
    printf(&quot;Hello OpenWrt\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进行交叉编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;architecture-openwrt-linux-uclibc-gcc helloopenwrt.c -o helloopenwrt.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将生成的&lt;code&gt;hellowopenwrt.o&lt;/code&gt;文件用scp上传到Easy-Link上，并用ssh登录到Easy-Link上，并运行，便可以看到终端输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello OpenWrt
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hombo.wang/openwrt/2014/08/11/helloworld_on_openwrt</link>
                <guid>http://hombo.wang/openwrt/2014/08/11/helloworld_on_openwrt</guid>
                <pubDate>2014-08-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>OpenWrt编译过程中出现的错误</title>
                <description>&lt;p&gt;编译OpenWrt不是件容易的事情，编译过程中要下载包，并且会出现很多奇怪的错误，经过几个小时的编译，终于成功了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;错误的捕获可以通过以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make V=99
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;下载错误&lt;/h1&gt;

&lt;p&gt;在编译的过程中，会从网上下载很多源码及包，由于服务器在国外，所以很不稳定，出现下载错误时，你可以多试几次，或者直接下载包放在相应目录。我的解决方法是用代理翻墙到国外下载。&lt;/p&gt;

&lt;h1 id=&quot;patch&quot;&gt;patch补丁文件错误&lt;/h1&gt;

&lt;p&gt;在编译过程中，可能会出现以下的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;malformed patch at line xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是由于应用patch 时都会检查受影响的行数是否与记录在两个 @@ 之间的数值一致，如果不一致的话，就要打开patch文件手动修改那个数值以符合受影响的行数。具体可以参考&lt;a href=&quot;http://blog.chinaunix.net/uid-11134731-id-33192.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;kconfig&quot;&gt;Kconfig错误&lt;/h1&gt;

&lt;p&gt;在编译时，可能某个Konfig文件出现以下的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;endif&#39; in different file than &#39;if&#39;
location of the &#39;if&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是Kconfig文件出现问题（&lt;a href=&quot;https://lkml.org/lkml/2010/9/27/533&quot;&gt;参考&lt;/a&gt;），只要打开相应的Kconfig文件，在他的最后一行加个加车就行了，我也不知道为什么。&lt;/p&gt;
</description>
                <link>http://hombo.wang/openwrt/2014/08/11/error_on_compiling_openwrt</link>
                <guid>http://hombo.wang/openwrt/2014/08/11/error_on_compiling_openwrt</guid>
                <pubDate>2014-08-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>OpenWrt的编译</title>
                <description>&lt;p&gt;最近在淘宝上买了基于AR9331的Easy-Link模块，尝试着编译了一下OpenWrt，编译环境为ubuntu 12.04。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;安装组件&lt;/h1&gt;

&lt;p&gt;打开终端，安装编译所需的组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev git-core gawk asciidoc libz-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;openwrt&quot;&gt;下载及更新Openwrt源码&lt;/h1&gt;

&lt;p&gt;打开终端，输入下以命令下载源码,当然还可以下载其它的版本，注意不要包含中文路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn co svn://svn.openwrt.org/openwrt/branches/attitude_adjustment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入源码目录，更新源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./scripts/feeds update -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装下载好的包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./scripts/feeds install -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;编译配置&lt;/h1&gt;

&lt;p&gt;打开终端，输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开OpenWrt配置界面进行配置。当然，Easy-Link有自己的补丁包。&lt;/p&gt;

&lt;p&gt;如果你想配置内核，可以在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make kernel_menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;编译&lt;/h1&gt;

&lt;p&gt;在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的2表示用2个线程进行编译，适用于多核CPU。在编译过程中会下载相应的文件，编译完成后，会在bin目录生成固件文件。&lt;/p&gt;

&lt;p&gt;如果想清除生成的文件，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想初始化编译环境，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make dirclean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想查看编译详细内容，或者捕获错误，可在终端中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make V=99
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hombo.wang/openwrt/2014/08/10/compile_openwrt</link>
                <guid>http://hombo.wang/openwrt/2014/08/10/compile_openwrt</guid>
                <pubDate>2014-08-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>VoCore启动成功</title>
                <description>&lt;p&gt;换了个VoCore板之后，VoCore就能正常启动了，顺便测试了一下ssh和ap+sta模式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;ssh&quot;&gt;SSH连接&lt;/h1&gt;

&lt;p&gt;VoCore连上电源后，等待大约30秒之后，便会有发出一个ssid为VoCore的无加密wifi。连上之后，在浏览器输入192.168.1.1，进入Openwrt的Luci界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/2014-08-06%2010:17:23%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户名为root，密码为vocore，登录进去之后，系统会提示修改密码并开启ssh，按照提示操作之后，打开终端，输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入密码之后，便可以登录进去了。&lt;/p&gt;

&lt;h1 id=&quot;staap&quot;&gt;STA+AP模式&lt;/h1&gt;

&lt;p&gt;根据作者博客介绍，VoCore的STA和AP能够同时工作。首先，开启STA模式，添加下面内容到｀/etc/config/network`。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config interface wwan
    option proto &#39;dhcp&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，修改&lt;code&gt;/etc/config/wireless&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config wifi-device  radio0
	option type     mac80211
	option channel  11
	option hwmode	11ng
	option path	&#39;10180000.wmac&#39;
	list ht_capab	GF
	list ht_capab	SHORT-GI-20
	list ht_capab	SHORT-GI-40
	list ht_capab	RX-STBC1
	option htmode	HT20

config wifi-iface
    option device   radio0
	option network  lan
	option mode     ap
	option ssid     VoCore
	option encryption none

config wifi-iface
	option device   radio0
	option network  wwan
	option mode     sta
    option ssid     VongerWifi
	option encryption psk2
	option key      PasswordForWifi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改相应ssid与密码即可。&lt;/p&gt;

&lt;p&gt;如果，你家的路由是用192.168.1.1作它的IP地址，那么为避免冲突，你必须修改VoCore的IP，修改文件里相应的IP，如192.168.61.1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config interface &#39;lan&#39;
	option ifname &#39;eth0.1&#39;
	option type &#39;bridge&#39;
	option proto &#39;static&#39;
	option ipaddr &#39;192.168.61.1&#39;
	option netmask &#39;255.255.255.0&#39;
	option ip6assign &#39;60&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启连接成功之后，VoCore便可以访问外网了。&lt;/p&gt;
</description>
                <link>http://hombo.wang/vocore/2014/08/06/first_start_of_vocore</link>
                <guid>http://hombo.wang/vocore/2014/08/06/first_start_of_vocore</guid>
                <pubDate>2014-08-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>为Jekyll增加不完美的分页和文章摘要</title>
                <description>&lt;p&gt;怎么说呢，用Jekyll搭建Blog不管被说的多么好用，但终究应该只属于技术宅+爱折腾的群体吧，经常一个Wordpress上的小功能，却要在Jekyll折腾不少时间，比如之前的站内搜索，以及今天的分页以及文章摘要，足足折腾了我一下午，而且最后的解决方案还是不完美，有点小挫败感。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;回到主题，下面先说下Jekyll分页，这个功能有内置的，但是非常见鬼的，只支持对index.html的分页，你没看错，文件名必须是这个，如果你是用JB的话，把index.md重命名成index.html，然后再继续往下看：&lt;/p&gt;

&lt;p&gt;修改_config.yml文件，增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 每一页显示的文章数
paginate: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加了上面后，你就可以在index.html页面中，引用paginator这个对象了，记住，只有index.html页面可以用。&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;变量名&lt;/td&gt;	                &lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.per_page&lt;/td&gt;     &lt;td&gt;每页的文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.posts&lt;/td&gt;        &lt;td&gt;这个分页下所有的文章列表&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_posts&lt;/td&gt;  &lt;td&gt;总文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_pages&lt;/td&gt;  &lt;td&gt;总页数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.page&lt;/td&gt;         &lt;td&gt;当前页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.previous_page&lt;/td&gt;&lt;td&gt;前一页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.next_page&lt;/td&gt;    &lt;td&gt;后一页&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;具体如何使用，参考&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Pagination&quot;&gt;How pagination works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;前面也提到了，这个只支持首页模式，也就是说，你的Blog里有多个文章类目，然后这个是不支持的，所以我称做为不完美的分页。不过我的Blog文章还少，而且我向来是个比较懒的人，等分类下的文章也多了，再来想怎么解决吧。&lt;/p&gt;

&lt;p&gt;下面说说怎么搞文章摘要，如果没有摘要的，列表展示是很头大的。目前有这么几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用内置的truncate或者truncatewords方法，这个好处是内置的，不需要装插件，不需要装插件意味着你可以在托管Github上用，因为Github上很多插件都不支持。但缺点也很明显，对html的标签支持不是很好，如果你是纯文本的Blog，倒也还好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装truncatehtml插件。这个插件首先需要nokogiri，所以你需要在本地安装，安装命令如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;gem install nokogiri
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后再安装上述的插件，这个插件的好处就是对解析后的html代码进行控制，但坏处就是，你如果是托管在Github上，那就悲剧了，不能用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面两种方法，都有一个问题，就是对所有文章的摘要提取都是一样的，但是有时候，对于不同的问题，我想显示不同长度的摘要，所以下面隆重祭出第三种方法（其实，也是我在网上找的，版权不归我哈）： 
首先，在你文章里，想要输出摘要的截至地方，打上标签，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ---
 title: some post
 layout: post
 ---

 我有一头小毛驴呀，从来也不骑。

 &amp;lt;!--break--&amp;gt;

 有一天我心血来潮骑它取赶集。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用下面的方式截取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  \{\{ post.content  | | split:&#39;&amp;lt;!--break--&amp;gt;&#39; | first \}\}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的方式，就是，你需要在写文章的时候，打一个注释，但是，这个成本，我想，还好吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&quot;&gt;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hombo.wang/daily/2014/08/04/paginate_and_excerpt_on_jekyll</link>
                <guid>http://hombo.wang/daily/2014/08/04/paginate_and_excerpt_on_jekyll</guid>
                <pubDate>2014-08-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>VoCore首次启动失败</title>
                <description>&lt;p&gt;本来以为首次启动应该顺顺利利的，但是，问题总是在遇到我的时候变得很复杂，问题总是以意思不到的形式出现，接上电源后，竞然搜不到ssid为VoCore的WiFi。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;vocore&quot;&gt;VoCore的电源&lt;/h1&gt;

&lt;p&gt;如图所示，VoCore输入电源3.3V~6.0V，经MT3410L转换成3.3V，再经MT3410L转成1.8V，给RT5350F供电。因此，只要输入5.0V的USB电源便可以正常运行了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDZ6oi/medium.jpg&quot; alt=&quot;VoCore电源&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本人决定用Mini USB线来改装。Mini USB有4条线，分别是红、白、绿、蓝（黑），其中红是正极，蓝（黑）是地，将这两根线接到图中红框所示的地方，便可以正常启动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DXff2TTy/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDWsPw/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;问题出现&lt;/h1&gt;

&lt;p&gt;接上5V USB电源之后，LED亮了大约1秒，之后，大约隔18秒之后，led亮了大约15秒，之后，又等了好久，始终看不到VoCore的Wifi出现。询问作者Vonger，Vonger表示led正常，要求给出USB-TTL的Log进行分析，所以又制作了VoCore的USB-TTL。&lt;/p&gt;

&lt;h1 id=&quot;usb-ttl&quot;&gt;USB-TTL输出&lt;/h1&gt;

&lt;p&gt;依照Vonger博客上的方法，使用USB-TTL模块，并将相应引脚接到红框部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DXfetmAA/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDVduJ/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;电脑端的串口调试客户端，我用的是putty，相关的串口参数如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;波特率57600&lt;/li&gt;
  &lt;li&gt;数据位8位&lt;/li&gt;
  &lt;li&gt;无校验位&lt;/li&gt;
  &lt;li&gt;停止位1位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后，便可以打印出log信息。&lt;/p&gt;
</description>
                <link>http://hombo.wang/vocore/2014/07/31/failed_on_first_start_of_vocore</link>
                <guid>http://hombo.wang/vocore/2014/07/31/failed_on_first_start_of_vocore</guid>
                <pubDate>2014-07-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>入手VoCore</title>
                <description>&lt;p&gt;由于项目需要用到RT5350，一个廉价的WiFi片上芯片，在网上搜索相关资料之后，找到了VoCore这个国内的开源项目，一个带用WiFi的硬币大小的Linux计算机。如果感兴趣的话可以了解一下&lt;a href=&quot;http://vonger.cn/&quot;&gt;作者的博客&lt;/a&gt;和&lt;a href=&quot;https://www.indiegogo.com/projects/vocore-a-coin-sized-linux-computer-with-wifi&quot;&gt;相关介绍&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;h1 id=&quot;vocore&quot;&gt;什么是VoCore？&lt;/h1&gt;
  &lt;p&gt;VoCore是运行OpenWrt的开源硬件。尽管WIFI, USB, UART, 20+ GPIO一应俱全，但是大小为1英寸（25mm x 25mm）。它提供了很多的接口，比如说10/100M以太网口、USB、UART、I2C、I2S、PCM、JTAG和超过20个的GPIO口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正如你所看到的，VoCore非常地小，接口也非常密，这个版本没有提代外接的天线，直接用贴片的天线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyLSbrI/medium.jpg&quot; alt=&quot;VoCore正面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyMgd04/medium.jpg&quot; alt=&quot;VoCore背面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下是它的接口/引脚图，接口非常的丰富，使用必须用电烙铁焊上去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWDDYtLs/medish.jpg&quot; alt=&quot;VoCore引脚图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者除了本身的博客之外，不提供其它的资料，所示还是先看看他的博客吧。&lt;/p&gt;
</description>
                <link>http://hombo.wang/vocore/2014/07/30/get_vocore</link>
                <guid>http://hombo.wang/vocore/2014/07/30/get_vocore</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在Jekyll上使用分页</title>
                <description>&lt;p&gt;一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;开启分页功能&lt;/h1&gt;

&lt;p&gt;首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paginate: 5
paginate_path: &quot;page:num&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推。&lt;/p&gt;

&lt;p&gt;需要注意的几个点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分页只在html文件中起作用&lt;/li&gt;
  &lt;li&gt;paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;使用分页&lt;/h1&gt;

&lt;p&gt;只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：&lt;/p&gt;

&lt;p&gt;这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;换页&lt;/h1&gt;

&lt;p&gt;只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性。&lt;/p&gt;

&lt;p&gt;首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的total_pages属性能判断总页数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.total_pages &amp;gt; 1 %}
&amp;lt;!-- 分页代码 --&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的previous_page属性来判断是否是第一个页面，使用paginator的previous_page_path来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.previous_page %}
    &amp;lt;a href=&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;上一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的page属性来确定当前页，如果是当前页，则按钮无效，否则使用&lt;code&gt;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&lt;/code&gt;来将&lt;code&gt;:num&lt;/code&gt;替换成当前页面的数字生成页面路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &amp;lt;span class=&quot;active&quot;&amp;gt;{{ page }}&amp;lt;/span&amp;gt;
    {% elsif page == 1 %}
      &amp;lt;a href=&quot;{{ &#39;/index.html&#39; | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% else %}
      &amp;lt;a href=&quot;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的next_page_path来确定是否还有下一页：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.next_page %}
    &amp;lt;a href=&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://blog.segmentfault.com/skyinlayer/1190000000406015&quot;&gt;http://blog.segmentfault.com/skyinlayer/1190000000406015&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hombo.wang/daily/2014/07/26/pagination_on_jekyll</link>
                <guid>http://hombo.wang/daily/2014/07/26/pagination_on_jekyll</guid>
                <pubDate>2014-07-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Win7/Win8.1打开文件夹时假死的解决办法</title>
                <description>&lt;p&gt;在使用Win8/Win8.1操作系统的过程中，可能会遇到打开文件夹假死现象，地址栏的绿色加载条缓慢前进。这种情况一般在打开了存放了大量可执行程序、图片或者视频的文件夹情况下比较常见。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;windows-defender&quot;&gt;思路一：关闭Windows Defender&lt;/h1&gt;

&lt;p&gt;如果你没有安装第三方防护软件，系统会默认开启自带的Windows Defender的，默认情况下，扫描文件时会占用大量的系统资源并会造成打开文件夹时假死；如果安装有其他防护软件，Windows Defender应该会自己关闭，如果没有关闭在服务中关闭“Windows Defender Service”服务即可。&lt;/p&gt;

&lt;p&gt;如果你只想使用Windows Defender作为基础防护的话，就需要设定特例了：&lt;/p&gt;

&lt;p&gt;打开Windows Defender，点击“设置”选项卡，在左侧就有相对应的例外设置。可以设置某些文件、文件夹作为例外，也可以设置某类型或某进程是不检查的。当然，例外的设置是需要你在可以熟知你所拥有的程序是无害的。在不添加例外的情况下，扫描结果仅对此次开机有效。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;思路二：重启桌面窗口管理器&lt;/h1&gt;

&lt;p&gt;1、按键盘的“Ctrl+Alt+Del”组合键，打开“任务管理器”，在“进程”选下卡找到“桌面窗口管理器”，结束之；&lt;/p&gt;

&lt;p&gt;2、此时桌面会变成只有背景的状态，继续在任务管理器中选择“文件”菜单下的“运行新任务”；&lt;/p&gt;

&lt;p&gt;3、输入“explorer”后回车，系统会重新启动桌面窗口管理器；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042222_226.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意使用这种方法会将已经打开的文件夹关闭，需要再次打开，如果有没有保存的工作请在操作前请注意保存。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;思路三：关闭文件预览，开启在单独的进程中打开文件夹窗口功能&lt;/h1&gt;

&lt;p&gt;1、在控制面板中找到“文件夹选项”，切换到“查看”选项卡；&lt;/p&gt;

&lt;p&gt;2、在文件夹选项中切换至“查看”选项卡，勾选“始终显示图标，从不显示缩略图”以及“在单独的进程中打开文件夹窗口”。保存并退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042239_954.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;思路四：关闭索引，提升响应速率&lt;/h1&gt;

&lt;p&gt;右键目标文件夹，选择“属性”，然后点击“常规”选项卡下的“高级”按钮，在弹出的对话框中取消“除了文件属性外，还允许索引此驱动器文件的内容”前面的对勾。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042252_543.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于驱动器属性，在“常规”选项卡中，取消对“除了文件属性外，还允许索引此驱动器文件的内容”的勾选（不建议对系统盘执行此操作，会花费较长的时间而且并不一定成功）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042306_570.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，根据IT之家网友的反馈，在Windows 8.1 2014 Update（17025）版本中取消了缩略图缓存文件的大小限制，这样如果你出现了因为生成缩略图缓慢的原因导致系统假死，又不想彻底关闭缩略图预览功能的话，不妨等一等，下次再打开相同的文件夹应该不会出现假死的问题了。&lt;/p&gt;

&lt;p&gt;以上就是IT之家小编为大家整理的一些解决Win8/Windows 8.1打开文件夹假死的解决办法，大家可以试试看，若在Windows Vista/Windows7上出现同样的问题，不妨按照原文的思路一试。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文章转自：&lt;a href=&quot;http://www.ithome.com/html/win8/73946.htm&quot;&gt;http://www.ithome.com/html/win8/73946.htm&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hombo.wang/daily/2014/04/28/win8_1_open_directory_problem</link>
                <guid>http://hombo.wang/daily/2014/04/28/win8_1_open_directory_problem</guid>
                <pubDate>2014-04-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Marvell88W8686的SPI主控接口</title>
                <description>&lt;p&gt;88w8686 是一款低成本、低功耗，支持IEEE 802.11a/g/b MAC/基带/射频(RF)无线局域网标准的片上系统,设计支持IEEE 802.11a/g标准的6、
9、12、18、24、36、48、54M 有效数据速率，和IEEE 802.11 b 标准的1、2、5.5、11 M 数据速率。88w8686 提供IEEE802.11/802.11 b 标准直接序列扩散光谱(DSSS),802.11a/ g 正交频分复用(OFDM)基带调制,媒体访问控制(MAC),CPU,内存,主机接口,直接转换收音机,无线局域网射频(RF）功能相结合的单一集成芯片。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;88w8686 核心功能单元,通过一个高通量互联系统相互连接，如图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184731593&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686 配备了一个完全集成的射频到基带收发器工作在2.4 GHz 的ISM 的802.11g/b端口WLAN应用和5 GHz的UNII WLA 802.11a的无线电波段的无线电波段。该收发器架构包括Marvell的第二代，专门设计用于手机通信。蜂窝频段发射杂散音，噪音和接收干扰被设计在其中。&lt;/p&gt;

&lt;p&gt;在手机中由于非常低的频谱发射接收频段，设备不会干扰手机接收和发送高
功率移动电话传输信号。为了获得最佳性能，接收路径上集成的LNA 和AGC 增益调整无缝控制基带功能。整个接收路径已超过90 分贝电压增益。&lt;/p&gt;

&lt;p&gt;综合发射机正交基带信号转换，然后为2.4 GHz 和5 GHz 无线电频带传输提供外部功率放大器的RF 信号。&lt;/p&gt;

&lt;p&gt;本振频率产生一个完全集成的可编程频率合成器，无需任何外部元件。环路
带宽优化相位噪声和动态效能集中在该芯片上。出于安全考虑，88W8686 支持IEEE 802.11i 安全标准，通过实施高级加密标准（AES）/计数器模式CBC - MAC 协议（CCMP），有线等效保密（WEP）临时密钥完整性协议（TKIP）安全机制。为视频，语音，和多媒体应用，88W8686 支持802.11e 的质量服务（QoS）。还支持蓝牙共存接口。88W8686 支持一个通用的SPI（G - SPI）和SDIO 主机接口，采用QFN 封装或倒装芯片封装。&lt;/p&gt;

&lt;h1 id=&quot;w8686-g-spi&quot;&gt;88W8686 G-SPI主控接口&lt;/h1&gt;

&lt;p&gt;88W8686&lt;em&gt;主机接口单元(Host Interface Unit,HIU)&lt;/em&gt;连接几个主机接口总线单元到设备(指88W8686)的内部总线上。每个HIU和其他HIU是通过共享到内部总线的连接，但88W8686每次只允许一个HIU被激活。&lt;/p&gt;

&lt;p&gt;88W8686的HIU支持G-SPI(通用的SPI)接口和SDIO接口。它支持一个通用的、半双工(half-duplex)、DMA辅助(DMA-assisted)的SPI接口，允许一个主控制器使用通用的SPI协议来访问WLAN设备(指88W8686)。G-SPI接口包含了外部SPI总线和内部共享总线之间的接口电路，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184736000&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686在SPI总线上表示为设备，主机单元能够直接访问G-SPI寄存器和通过使用BARs(Base Address Register，基地址寄存器)和DMA引擎来访问设备的共享内存。&lt;/p&gt;

&lt;p&gt;SPI单元支持通用的SPI接口协议，工作速率可达50MHz，此接口支持下面的功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SPI单元总线设备操作&lt;/li&gt;
  &lt;li&gt;SPI单元寄存器读写&lt;/li&gt;
  &lt;li&gt;对内部CPU产生中断&lt;/li&gt;
  &lt;li&gt;对外部SPI主控制器产生中断(比如S3C2451的SPI控制器)&lt;/li&gt;
  &lt;li&gt;通过DMA访问内部共享内存&lt;/li&gt;
  &lt;li&gt;对电源管理单元产生唤醒中断&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;g-spi&quot;&gt;G-SPI接口信号描述&lt;/h1&gt;

&lt;p&gt;88W8686复位后，紧接着使用下面配置输入引脚来设置参数，但是在88W8686复位到一定时间之后，这些引脚立刻改为变他们通常的功能，比如GPIO[5]就作为通常的功能使用。如果要设置一个配置位为0，通过连接一个阻值为100 kΩ的下拉电阻，比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184739406&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果要设置一个配置位为1，则不需要接外部电路&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184743000&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686的配置引脚如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184747203&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看G-SPI接口引脚的说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184751296&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;g-spi-1&quot;&gt;G-SPI接口功能描述&lt;/h1&gt;

&lt;p&gt;G-SPI接口的标准G-SPI物理总线上支持多种简单的地址/数据协议，这些协议通过地址的位数和数据的顺序来区分。&lt;/p&gt;

&lt;p&gt;每次通讯由主机通过拉低SCSn信号来发起，从机在检测到SCSn有效(低电平)之后，在每个SCLK的上升沿锁存SDI引脚上输入的数据。当从机要输出数据时，在SCLK的下降沿送出数据。SCLK输入信号在每次通讯的开始和结束都为低电平，中断输入信号SINTn由设备发送给主机(比如S3C2451的SPI主控制器)&lt;/p&gt;

&lt;h2 id=&quot;transaction-delay&quot;&gt;通讯时延(transaction delay)&lt;/h2&gt;

&lt;p&gt;第一个数据块是从主机发送到设备(从机)的，这个数据块包含一个地址和读/写标志，地址的最高位(MSB)如果为0表示读，如果为1表示写。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写操作时延(write Write Transaction Delay)
 &amp;gt;对于写操作，写操作的数据段紧跟着地址段，地址和数据段之间，不需要主机产生低时钟脉冲。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读操作时延(read Write Transaction Delay)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;读操作时，在总线上地址段之后和数据段之前要求有一些时延。这些时延表现为&lt;em&gt;TDDR(time delay read register，读寄存器时延)&lt;/em&gt;和&lt;em&gt;TDRP(timedelay read port，读端口时延)&lt;/em&gt;，这些时延表示设备需要需要一些时间来准备有效数据给主机。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有两种方式来建立这些时延：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一种：主机通过发送一定数量的&lt;em&gt;虚拟时钟周期(a known number of dummyclock cycles)&lt;/em&gt;到设备来创建读操作时延，这些虚拟时钟周期定义在&lt;em&gt;延迟读寄存器(delay readregister)&lt;/em&gt;中，也就是说主机要发送的&lt;em&gt;虚拟时钟周期&lt;/em&gt;数量由&lt;em&gt;延迟读寄存器&lt;/em&gt;的值来定，下面来看此寄存器的定义：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184755281&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上图可知&lt;em&gt;Delay Method&lt;/em&gt;的值由&lt;em&gt;SPU Bus Mode寄存器&lt;/em&gt;(&lt;code&gt;offset 0x70[2]=1&lt;/code&gt;)的&lt;em&gt;Delay_Method&lt;/em&gt;位的值来决定，下面来看此寄存器的定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184803765&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SPU(SPI host interface unit)表示SPI主机接口单元。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第二种：通过主机在地址段和数据段之间保持(holding)低时钟信号至少一段时间来创建读操作时延(the delay is created bythe host holding the clock signal low for a minimum period of time between the addressand data phases)，此模式通过设置&lt;code&gt;0x70[2]=0&lt;/code&gt;来选择。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在读操作的数据段区间，主机继续提供时钟脉冲和同时驱动数据到SDI输入引脚或从SDO输出引脚读取数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;数据传输&lt;/h2&gt;

&lt;p&gt;主机经常访问G-SPI单元的配置寄存器，为了访问内部内存空间，一些寄存器被定义为端口寄存器。当访问端口寄存器时，从机使用相应的基地址寄存器(BAR)和DMA引擎来从内部内存空间读取数据，或是写入数据内部内存空间。&lt;/p&gt;

&lt;p&gt;主机和从机间的每一次传输都是&lt;em&gt;突发模式&lt;/em&gt;(一个地址后面跟着多个数据)，在读或写完所要求数量的数据后，主机通过拉高SCSn引脚来结束此次传输。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;端口寄存器访问&lt;/h3&gt;

&lt;p&gt;主机读&lt;em&gt;端口寄存器&lt;/em&gt;时，对于&lt;em&gt;突发模式&lt;/em&gt;的数据长度没有限制(除了内部总线的有效地址范围限制之外)。主机写端口寄存器时，对&lt;em&gt;突发模式&lt;/em&gt;的数据长度唯一要求是：长度是DWORDS的倍数。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;端口寄存器&lt;/em&gt;(I/O端口，命令端口，数据端口)被用来访问内部32-bit存储空间和总是32-bit对齐访问。每个端口寄存器都有一个相应的BAR用来读写(BAR作为一个指针指向要读写的内存空间的开始物理地址)。内存也只能32-bit对齐访问，这通过向相应的BAR写入32-bit对齐的数据来是实现，在访问期间，第16bits数据总线最先出现在总线上。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写数据到端口寄存器&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;写数据到端口寄存器，就是依次填满起始位置在BAR的连续的32-bit内存空间。当从从机的数据和命令端口读数据时，DMA引擎连续填充FIFO知道剩余空间不足8个DWORDs。当写数据到设备时，拉高SCSn信号脚来清空FIFO。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从端口寄存器读数据&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当从设备的I/O端口读数据时，可以选择DMA引擎是执行单一读或是突发模式读。突发模式读与读端口和命令端口一样，单一模式读让DMA引擎在内部总线上指向单个DWORD访问。单一模式读通讯必须在返回数据的第一或是第二个16-bit块之后终止。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置寄存器访问&lt;/h3&gt;

&lt;p&gt;当主机访问端口寄存器之外的其他寄存器时，突发模式长度必须限制在一个16-bit的数，或是如果地址是以DWORD边界对齐的两个16-bit数。当内部总线的单元访问G-SPI接口寄存器，则必须是单个DWORD或是更小来访问。&lt;/p&gt;

&lt;p&gt;G-SPI除了端口寄存器之外的接口寄存器，都能以16-bit边界对齐的方式读或是写。当单个16-bit word被读出或写入，通讯可以被终止。&lt;/p&gt;

&lt;h2 id=&quot;g-si&quot;&gt;G-SI时钟频率&lt;/h2&gt;

&lt;p&gt;G-SPI时钟频率不能大于内部总线时钟频率的2.5倍，内部总线时钟频率&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184803765&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;数据格式&lt;/h2&gt;

&lt;p&gt;总共有16个有效数据格式，下面9个数据格式是可用的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有4读数据格式，在地址段和数据段之间的延迟时间，时钟信号保持为低电平。&lt;/li&gt;
  &lt;li&gt;所有4个写数据格式。&lt;/li&gt;
  &lt;li&gt;1个读数据格式，在地址段和数据段之间的延迟时间，时钟信号切换为固定数量的周期。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每种读写操作类型都有两种地址长度，要么是8-bit要么是16-bit，而每种地址长度对应有两种数据顺序。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;可编程的时钟周期延迟&lt;/h3&gt;

&lt;p&gt;下面是&lt;code&gt;Delay_Method=0&lt;/code&gt;的读数据格式，在这种模式下，&lt;code&gt;tdr(r/p)&lt;/code&gt;的值代表最后一个地址位和第一个数据位之间的延时时间，这段时间内时钟信号SCLK保持为低电平。有两个不同的延时值，包括从G-SPI配置寄存器读取的值和从G-SPI端口寄存器读取的值。一旦读写操作指定的时延期满，有效的数据就从设备中发出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读数据格式&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184808203&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写数据格式&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184812765&quot; alt=&quot;&quot; /&gt; &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;固定的时钟周期延迟&lt;/h3&gt;

&lt;p&gt;下面是读数据格式的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184816609&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前我们G-SPI驱动读数据格式就是采用这种格式。&lt;/p&gt;

&lt;h2 id=&quot;g-spi-2&quot;&gt;G-SPI接口寄存器内存空间&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184820203&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文章转自：&lt;a href=&quot;http://blog.csdn.net/loongembedded/article/details/9067013&quot;&gt;http://blog.csdn.net/loongembedded/article/details/9067013&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hombo.wang/embedded/2014/04/20/Marvell88W8686_SPI_Interface</link>
                <guid>http://hombo.wang/embedded/2014/04/20/Marvell88W8686_SPI_Interface</guid>
                <pubDate>2014-04-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>批量删除Kindle云端的个人文档</title>
                <description>&lt;p&gt;在使用Kindle的推送时，有一个不好的地方就是，推送的电子书会被放到云端，而且要删除的话不能批量删，长年累月就积累了一大批。本人找到一种方法可以批量删除当前&lt;em&gt;个人文档&lt;/em&gt;页面的电子书。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先，登录&lt;em&gt;amazon&lt;/em&gt;，并点击个人文档，将以下代码复制进地址栏中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:(function(){ var v = new RegExp(&quot;PersonalDocuments&quot;); if (!v.test(document.URL)) { return false; } {a=document.getElementsByClassName(&#39;rowBodyCollapsed&#39;);for(var i = 0; i&amp;lt;a.length; i++){Fion.deleteItem(&#39;deleteItem_&#39;+a[i].getAttribute(&#39;asin&#39;));};return; }})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按回车后，便会删除当前页面的电子书。当然，你也可以在搜索框搜索电子书，再输入以上代码删除搜索结果页面的电子书。&lt;/p&gt;

&lt;p&gt;这里有一个要注意的地方，如果你使用的浏览器是&lt;em&gt;chrome&lt;/em&gt;的话，以上代码复制进地址栏时，&lt;em&gt;javascript&lt;/em&gt;这个关键字会被注释掉，可以复制进地址栏之后，再在前面添加&lt;em&gt;javascript&lt;/em&gt;关键字。当然，你也可以按&lt;em&gt;F12&lt;/em&gt;进入打开&lt;em&gt;开发者工具&lt;/em&gt;，再点击&lt;em&gt;Console&lt;/em&gt;,再输入以上代码。&lt;/p&gt;
</description>
                <link>http://hombo.wang/daily/2014/04/18/delete_document_on_kindle_cloud</link>
                <guid>http://hombo.wang/daily/2014/04/18/delete_document_on_kindle_cloud</guid>
                <pubDate>2014-04-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sk_buff结构分析</title>
                <description>&lt;p&gt;在wlan驱动中，数据读取写入是通过&lt;code&gt;sk_buff&lt;/code&gt;这个结构体，而&lt;code&gt;sk_buff&lt;/code&gt;结构主要作用是包含接收的缓冲数据，和它的包头信息。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如下是&lt;code&gt;sk_buff&lt;/code&gt;的主要结构成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sk_buff {
...
	unsigned char *head;
	unsigned char *data;
	unsigned char *tail;
	unsigned char *end;
...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;sk_buff&lt;/code&gt;还包含一些链表的东西，在此处并不做解析。在以上结构体中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;head&lt;/code&gt;：报文缓冲区的头；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;data&lt;/code&gt;：数据的头指针；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tail&lt;/code&gt;：数据的尾指针；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;end&lt;/code&gt; ：报文缓冲区的尾部。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如图所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9tAj/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分别有三个空间：&lt;em&gt;head room&lt;/em&gt;、&lt;em&gt;packet data&lt;/em&gt;、&lt;em&gt;tail room&lt;/em&gt;。其中&lt;em&gt;packet data&lt;/em&gt;是数据所在区包括数据的包头，&lt;em&gt;head room&lt;/em&gt;是数据头部增长的预留空间、&lt;em&gt;tail room&lt;/em&gt;是尾部增加的空间。预留头部使用&lt;code&gt;skb_reserve(skb, header_len);&lt;/code&gt;函数，尾部增加使用&lt;code&gt;skb_put()&lt;/code&gt;，头部增长使用&lt;code&gt;skb_push()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以下图是调用分配空间函数，即初始化函数&lt;code&gt;alloc_skb(len, GFP_KERNEL)&lt;/code&gt;的样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDLzyp1/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，&lt;code&gt;head&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;和&lt;code&gt;tail&lt;/code&gt;都指向了缓冲区的起始，而end指向结束。这个SKB的数据长度为0，不包含任何数据。&lt;/p&gt;

&lt;p&gt;接着调用了&lt;code&gt;skb_reserve(skb, header_len)&lt;/code&gt;预留了头部数据，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9eQx/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过调用&lt;code&gt;skb_put()&lt;/code&gt;向尾部增长数据，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9fX0/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过调用&lt;code&gt;skb_push()&lt;/code&gt;向头部增长数据，如图所示，增加了一个UDP头：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM8T7V/medium.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文考参：&lt;a href=&quot;http://vger.kernel.org/~davem/skb_data.html&quot;&gt;http://vger.kernel.org/~davem/skb_data.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://hombo.wang/linux/2014/04/16/sk_buff_analysis</link>
                <guid>http://hombo.wang/linux/2014/04/16/sk_buff_analysis</guid>
                <pubDate>2014-04-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>QF9700 Linux 3.0.8驱动补丁</title>
                <description>&lt;p&gt;网上有QF9700/RD9700的开源驱动，&lt;a href=&quot;http://www.elite.uk.com/mike/qf9700/&quot;&gt;点此下载&lt;/a&gt;。但是最高只支持Linux 2.6.32，在Linux 3.0.8编译下会出现错误，如下：&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code&gt;Building QF9700 USB2NET chip driver...
make[1]: 正在进入目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8&#39;
  CC [M]  /home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c: In function &#39;qf9700_set_multicast&#39;:
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:356:45: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:358:16: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:359:36: error: &#39;struct net_device&#39; has no member named &#39;mc_list&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:22: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:56: error: dereferencing pointer to incomplete type
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:363:14: error: dereferencing pointer to incomplete type
make[2]: *** [/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o] 错误 1
make[1]: *** [_module_/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700] 错误 2
make[1]:正在离开目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8&#39;
make: *** [all] 错误 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为此，写了一个补丁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff -ur b/qf9700.c a/qf9700.c
--- b/qf9700.c	2011-01-21 17:59:58.000000000 +0800
+++ a/qf9700.c	2014-04-15 18:37:50.000000000 +0800
@@ -353,14 +353,13 @@
 
 	if (net-&amp;gt;flags &amp;amp; IFF_PROMISC) {
 		rx_ctl |= 0x02;
-	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || net-&amp;gt;mc_count &amp;gt; QF_MCAST_MAX) {
+	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || netdev_mc_count(net) &amp;gt; QF_MCAST_MAX) {
 		rx_ctl |= 0x04;
-	} else if (net-&amp;gt;mc_count) {
-		struct dev_mc_list *mc_list = net-&amp;gt;mc_list;
-		int i;
+	} else if (netdev_mc_count(net)) {
+		struct netdev_hw_addr *hw_addr;
 
-		for (i = 0; i &amp;lt; net-&amp;gt;mc_count; i++, mc_list = mc_list-&amp;gt;next) {
-			u32 crc = ether_crc(ETH_ALEN, mc_list-&amp;gt;dmi_addr) &amp;gt;&amp;gt; 26;
+		netdev_for_each_mc_addr(hw_addr, net) {
+			u32 crc = ether_crc(ETH_ALEN, hw_addr-&amp;gt;addr) &amp;gt;&amp;gt; 26;
 			hashes[crc &amp;gt;&amp;gt; 3] |= 1 &amp;lt;&amp;lt; (crc &amp;amp; 0x7);
 		}
 	}
@@ -413,9 +412,9 @@
 
 	/* power up and reset phy */
 	qf_write_reg(dev, PRR, 1);
-	udelay(20 * 1000);	// at least 10ms, here 20ms for safe
+	mdelay(20);	// at least 10ms, here 20ms for safe
 	qf_write_reg(dev, PRR, 0);
-	udelay(2 * 1000);	// at least 1ms, here 2ms for reading right register
+	mdelay(2);	// at least 1ms, here 2ms for reading right register
 
 	/* receive broadcast packets */
 	qf9700_set_multicast(dev-&amp;gt;net);
diff -ur b/qf9700.h a/qf9700.h
--- b/qf9700.h	2010-10-09 16:51:00.000000000 +0800
+++ a/qf9700.h	2014-04-15 17:20:23.000000000 +0800
@@ -150,4 +150,21 @@
 #define	QF_TX_OVERHEAD		2	// 2bytes header
 #define	QF_RX_OVERHEAD		7	// 3bytes header + 4crc tail
 
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+        printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) \
+        ({ if (0) printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , \
+                ## arg); 0; })
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+        printk(KERN_ERR &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+        printk(KERN_WARNING &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+        printk(KERN_INFO &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg); \
+
 /*----------------------------------------------------------------------------------------------*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1sjKysEx&quot;&gt;点此&lt;/a&gt;下载源文件及补丁文件。&lt;/p&gt;
</description>
                <link>http://hombo.wang/linux/2014/04/15/qf9700_for_linux_3.0.8</link>
                <guid>http://hombo.wang/linux/2014/04/15/qf9700_for_linux_3.0.8</guid>
                <pubDate>2014-04-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Marvel 88w8686 Linux驱动分析</title>
                <description>&lt;p&gt;由于编写Marvel 88w8686 wlan模块SPI接口的&lt;em&gt;stm32&lt;/em&gt;驱动的需要，对&lt;a href=&quot;http://pan.baidu.com/s/1dDiSZFb&quot;&gt;Marvel 88w8686 Linux&lt;/a&gt; SPI接口的驱动进行了分析和参考。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;marvel&quot;&gt;Marvel驱动的使用&lt;/h1&gt;

&lt;p&gt;88w8686的Linux驱动是通过模块方式载入内核的，在使用时加载进去就行了，88w8686的Linux驱动还包含了sdio的驱动，加载时，还必须加载sdio驱动。在运行&lt;code&gt;make&lt;/code&gt;命令进行编译后，会生成&lt;code&gt;sdio.o&lt;/code&gt;和&lt;code&gt;sd8386.o&lt;/code&gt;文件，在终端下输入下列命令进行加载：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insmod sdio.o
insmod sd8385.o
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;marvel-1&quot;&gt;Marvel驱动源码分析&lt;/h1&gt;

&lt;p&gt;了解完如何使用Marvel 88w8686 Linux驱动后，便可以进行驱动源码的分析。源码&lt;a href=&quot;http://pan.baidu.com/s/1dDiSZFb&quot;&gt;点击此处&lt;/a&gt;下载。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;源码目录结构&lt;/h2&gt;

&lt;p&gt;源码的目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├─app
│  └─wlanconfig
├─config
├─if
│  └─if_gspi
├─io
│  └─gspi
│      └─pxa270
├─os
│  └─linux
└─wlan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;em&gt;app文件夹&lt;/em&gt;是驱动自带的wlanconfig工具，用于配置wifi的参数，本文不进行分析。&lt;em&gt;config文件夹&lt;/em&gt;包含的是一些配置文件，不进行分析。if文件夹包含的是关于GSPI操作的接口，包括固件。&lt;em&gt;io文件夹&lt;/em&gt;包含的是GSPI驱动。&lt;em&gt;os文件夹&lt;/em&gt;包含的是与系统相关的操作与头文件。&lt;em&gt;wlan文件夹&lt;/em&gt;是wifi驱动的主要目录，在本文进行重点分析。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;驱动的启动流程&lt;/h2&gt;

&lt;p&gt;由上文可知，wlan驱动是通过&lt;code&gt;insmod&lt;/code&gt;进加载的。在文件&lt;code&gt;wlan/wlan_main.c&lt;/code&gt;末尾处可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module_init(wlan_init_module);
module_exit(wlan_cleanup_module);

MODULE_DESCRIPTION(&quot;M-WLAN Driver&quot;);
MODULE_AUTHOR(&quot;Marvell International Ltd.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几个宏说明了wlan驱动模块的入口，知道其初始化函数是&lt;code&gt;wlan_init_module&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再来看看&lt;code&gt;wlan_init_module&lt;/code&gt;函数，在其函数中，调用了以下函数对网卡插入和移除时调用的函数进行了注册，即当电脑检测到网卡时有调用&lt;code&gt;wlan_add_card&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sbi_register(wlan_add_card, wlan_remove_card, NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;wlan_add_card&lt;/code&gt;中，进行初始化后，以下函数启动了内核主线程&lt;code&gt;wlan_service_main_thread&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wlan_create_thread(wlan_service_main_thread, &amp;amp;priv-&amp;gt;MainThread, &quot;wlan_main_service&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核主线程&lt;/h3&gt;

&lt;p&gt;内核主线程&lt;code&gt;wlan_service_main_thread&lt;/code&gt;承担了wlan驱动的主要工作，它主要是处理wlan固件的事件，wlan固件接受到的数据和内核传来的数据。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;wlan_service_main_thread&lt;/code&gt;函数中有一个&lt;code&gt;for&lt;/code&gt;死循环，所有数据处理都在循环里面。&lt;/p&gt;

&lt;p&gt;在主循环里面，首先调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
...
schedule();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让主线程进入可中断的等待模式，等到事件到来。当主线程被唤醒时，即有数据要处理，便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sbi_get_int_status(priv, &amp;amp;ireg)；
...
Adapter-&amp;gt;HisRegCpy |= ireg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先读取网卡固件发来的数据及标志位，将标志位存入&lt;code&gt;Adapter-&amp;gt;HisRegCpy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;紧接着便对标志位进行判断：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Command response? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CmdUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Cmd response ready.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CmdUpLdRdy;
	OS_INT_RESTORE;

	wlan_process_rx_command(priv);
}

/* Any received data? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_RxUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Rx Packet ready.\n&quot;);
	
	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_RxUpLdRdy;
	OS_INT_RESTORE;

	wlan_send_rxskbQ(priv);
}

/* Any Card Event */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CardEvent) {
	PRINTM(INFO, &quot;main-thread: Card Event Activity.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CardEvent;
	OS_INT_RESTORE;

	if (sbi_read_event_cause(priv)) {
		PRINTM(MSG, &quot;main-thread: sbi_read_event_cause failed.\n&quot;);
		continue;
	}
	wlan_process_event(priv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且调用相应的处理函数，对数据进行处理。&lt;/p&gt;

&lt;p&gt;当然进程中还对wlan的PS（Power Save）模式和WMM（WiFi-MultiMedia）进行判断处理，本文不进行分析。&lt;/p&gt;

&lt;p&gt;接着，便对内核发来的命令进行处理（比如说连接命令，扫描命令）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Execute the next command */
if (!priv-&amp;gt;wlan_dev.dnld_sent &amp;amp;&amp;amp; !Adapter-&amp;gt;CurCmd) {
	ExecuteNextCommand(priv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，之后便进入等待事件状态，重复以上过程。&lt;/p&gt;

&lt;h3 id=&quot;wlan&quot;&gt;wlan固件数据/事件&lt;/h3&gt;

&lt;p&gt;当wlan固件有数据/事件时，GSPI驱动会产生中断，它的中断处理函数为&lt;code&gt;sbi_interrupt&lt;/code&gt;，在&lt;code&gt;sbi_interrupt&lt;/code&gt;中调用了&lt;code&gt;wlan_interrupt&lt;/code&gt;,在&lt;code&gt;wlan_interrupt&lt;/code&gt;中，调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唤醒了主线程，对数据进行处理。上面介绍过，主线程调用&lt;code&gt;sbi_get_int_status(priv, &amp;amp;ireg)&lt;/code&gt;读取数据和标志位。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;应用层调用驱动接口&lt;/h3&gt;

&lt;p&gt;该wlan驱动接口是wext（Wireless Extensions无线扩展接口）。wext的接口实现上，应用层采用ioctl方式访问驱动，设置无线参数或者获取无线参数，配置无线驱动进行联网操作。无线驱动事件到应用层的传递采用的netlink socket技术，一种netlink route消息技术。这也是很多其他类型的驱动标准的实现方法。具体调用方法可以参考&lt;code&gt;wlanconfig&lt;/code&gt;，比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ioctl(sockfd, SIOCGIWSCAN, &amp;amp;iwr));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用wlan驱动扫描命令。如下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = socket(PF_INET, SOCK_DGRAM, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建了一个netlink连接。&lt;/p&gt;

&lt;p&gt;所有的ioctl的回调函数在，wlan_wext.c的&lt;code&gt;wlan_handler&lt;/code&gt;数组中，这里对&lt;code&gt;SIOCGIWSCAN&lt;/code&gt;即wlan扫描进行分析。可以看到wlan扫描的回调函数是&lt;code&gt;wlan_get_scan&lt;/code&gt;和&lt;code&gt;wlan_set_scan&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;先来看看&lt;code&gt;wlan_set_scan&lt;/code&gt;，在&lt;code&gt;wlan_set_scan&lt;/code&gt;函数中又调用了&lt;code&gt;wlan_scan_networks&lt;/code&gt;,在&lt;code&gt;wlan_scan_networks&lt;/code&gt;中调用了&lt;code&gt;wlan_scan_channel_list&lt;/code&gt;将命令添加到命令队列中，并等待命令执行响应，然后调用&lt;code&gt;wlan_scan_process_results&lt;/code&gt;更新&lt;code&gt;priv&lt;/code&gt;中的扫描表。&lt;/p&gt;

&lt;p&gt;在函数&lt;code&gt;wlan_scan_channel_list&lt;/code&gt;中调用&lt;code&gt;PrepareAndSendCommand&lt;/code&gt;将命令添加到命令列表。等发送到固件的数据和固件发送过来的数据都存在&lt;code&gt;CmdNode-&amp;gt;BufVirtualAddr&lt;/code&gt;指针指向的数据中，接着调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QueueCmd(Adapter, CmdNode, TRUE);
wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将命令加入命令队列，接着唤醒主线程处理命令，然后执行如下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait_event_interruptible(CmdNode-&amp;gt;cmdwait_q, CmdNode-&amp;gt;CmdWaitQWoken);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待结果，当&lt;code&gt;CmdNode-&amp;gt;CmdWaitQWoken&lt;/code&gt;为&lt;code&gt;TRUE&lt;/code&gt;时唤醒。&lt;/p&gt;

&lt;p&gt;在主线程中，由上面知道，调用&lt;code&gt;ExecuteNextCommand&lt;/code&gt;执行内核发来的命令。在&lt;code&gt;ExecuteNextCommand&lt;/code&gt;函数中调用&lt;code&gt;DownloadCommandToStation&lt;/code&gt;下载命令，&lt;code&gt;DownloadCommandToStation&lt;/code&gt;中，先调用&lt;code&gt;sbi_host_to_card&lt;/code&gt;下载命令，然后调用&lt;code&gt;ModTimer&lt;/code&gt;进行超时时重新发送。&lt;/p&gt;

&lt;p&gt;接下来，便是等待响应，当固件对发来的命令响应时，会触发中断，如上文说的调用&lt;code&gt;wlan_process_rx_command&lt;/code&gt;处理固件对命令的响应。在&lt;code&gt;wlan_process_rx_command&lt;/code&gt;中处理完成之后，会调用&lt;code&gt;CleanupAndInsertCmd&lt;/code&gt;回收命令，此时的&lt;code&gt;CmdNode-&amp;gt;CmdWaitQWoken&lt;/code&gt;为&lt;code&gt;TRUE&lt;/code&gt;，下次&lt;code&gt;schedule&lt;/code&gt;时便，唤醒上面等待命令响应的线程，让其继续执行。&lt;/p&gt;

&lt;p&gt;整个驱动运行的流程便是这样子。&lt;/p&gt;
</description>
                <link>http://hombo.wang/embedded/2014/04/14/marvel_88w8686_wifi_linux_driver_analysis</link>
                <guid>http://hombo.wang/embedded/2014/04/14/marvel_88w8686_wifi_linux_driver_analysis</guid>
                <pubDate>2014-04-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>强化你的Terminal IDE——在android平板/手机上编写C/C++</title>
                <description>&lt;p&gt;Terminal IDE是一个可扩展的终端应用，其包含了全功能的Java/HTML/Android开发套件。Terminal IDE集成了VIM, ssh, git等多个功能，其中强大之处，大家自己发觉，如果你用惯了Linux下的shell命令，那么用Terminal IDE你将会得心应手，喜欢上它的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;虽然Terminal IDE很强大，可以编写Java，android，但它没有gcc/g++。没关系，Terminal IDE强大之处就在于它是可拓展的，具体可以看它的Help。此处，我说明一下，如何把gcc/g++加入Terminal IDE，其实就是将linux-arm-gcc加入Terminal IDE 。 &lt;/p&gt;

&lt;p&gt;首先，将&lt;a href=&quot;http://www.kuaipan.cn/file/id_41572487401570322.htm&quot;&gt;linux-arm-gcc&lt;/a&gt;解压到Terminal IDE中的&lt;code&gt;~/system&lt;/code&gt;目录下(不是系统的&lt;code&gt;/system/&lt;/code&gt;，其真正目录为:&lt;code&gt;data/data/com.spartacusrex.spartacuside/files/system&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;修改该’gcc’目录为可读写，在Terminal IDE下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod -R 777 ./gcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;~&lt;/code&gt;(即&lt;code&gt;data/data/com.spartacusrex.spartacuside/files/&lt;/code&gt;)目录下的&lt;code&gt;.bashrc&lt;/code&gt;文件。添加需要的环境变量，在&lt;code&gt;~/.bashrc&lt;/code&gt;文件添加如下环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export CPLUS_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/c++/include:$CPLUS_INCLUDE_PATH
export C_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/include:$C_INCLUDE_PATH
export PATH=$IDESYSTEM/gcc/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;gcc/bin&lt;/code&gt;下的相应文件改一下名，改为&lt;code&gt;gcc&lt;/code&gt;和&lt;code&gt;g++&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再重启Terminal IDE后(需按TerminalIDE的Shutdown按钮)，便可以使用gcc和g++进行c++/c的编译，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim a.cpp   //写入代吗
g++ a.cpp   //编译
./a.out     //运行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，再用otg接个键盘或者用蓝牙键盘的话，那么整个apad就相当于你的电脑，得心应手。&lt;/p&gt;

&lt;p&gt;如果你熟悉Linux和vim，以上方法是不错的选择，如果不熟悉的话，可以用C4droid。这里在贴出几个工具：（下载地址可以自己搜，我只贴出GooglePlay上的地址。）&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.aide.ui&amp;amp;hl=en&quot;&gt;AIDE&lt;/a&gt;：可以在android平板/手机上编写android应用，编译后可直接安装。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.n0n3m4.droidc&amp;amp;hl=en&quot;&gt;C4droid&lt;/a&gt;：可以在android平板/手机上编写并编译c/c++，不过不够强大。但比较容易安装。&lt;/p&gt;

&lt;p&gt;　　ADDI：可以在android平板/手机上执行少量的matlab指令。&lt;/p&gt;

&lt;p&gt;以上适合apad+键盘，如果没有键盘的话，我觉得还是别折腾了，没有这个必要吧。写一写小程序还是可以的，大的项目就不行了，编译会很慢的。&lt;/p&gt;
</description>
                <link>http://hombo.wang/android/2012/11/24/c_on_android</link>
                <guid>http://hombo.wang/android/2012/11/24/c_on_android</guid>
                <pubDate>2012-11-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
