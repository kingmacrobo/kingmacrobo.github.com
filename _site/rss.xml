<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Hombo's Blog</title>
        <description>Hombo's Blog - Hombo Wang</description>
        <link>http://hombo.wang</link>
        <link>http://hombo.wang</link>
        <lastBuildDate>2015-06-02T17:21:11+08:00</lastBuildDate>
        <pubDate>2015-06-02T17:21:11+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Permutation</title>
                <description>&lt;p&gt;leetcode上有四道关于排列的题，分别是：Next Permutation， Permutations， Permutations II 和 Permutation Sequence。对于Next Permutation和Permutation Sequence， 都是关于排列的字母序的，基本思想类似。对于Permutations和Permutations II，差别只是在于是否有重复的元素，有重复元素的实现会涉及到组合问题，比较棘手。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;什么是排列的字母序&lt;/h3&gt;
&lt;p&gt;这里的字母序和字符串比较的字母序一样，例如123的排列按字母顺序为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;123
132
213
231
312
321
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;next-permutation&quot;&gt;Next Permutation&lt;/h3&gt;

&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是找出给出的排列在字母序中的下一个排列。&lt;/p&gt;

&lt;p&gt;首先我们需要寻找规律，两个相邻的排列是怎么转换得到的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2,3 -&amp;gt; 1,3,2 交换2 和 3
1,2,4,5,3 -&amp;gt; 1,2,5,3,4 交换4和5，然后交换3和4
1,2,4,6,5,3 -&amp;gt; 1,2,5,3,4,6 交换4和6，然后对后面进行从小到大排序！
1,2,4,7,6,5,3 -&amp;gt; 1,2,5,3,4,6,7 交换4和5，然后对后面从小到大排序！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，我们应该是能发现规律了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从右边开始往左找，找到第一个后面数大于前面数的位置，然后往后找到最后一个比前面数大的位置，交换两个数，然后将后面的所有数进行从小到大排序！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们从理论上分析上面做法的正确性：&lt;/p&gt;

&lt;p&gt;如果对于排列P，想找到它的相邻的下一个排列，那么由于是字母序的，所以我们要尽可能的在右边做交换，又由于想要增大字母序，必须将一个大的数和它左边比它小的数进行交换，因此我们从右边开始往左找，也就是说，这两个要交换的数尽量考右，而上面的找法，先找到了左边比右边小的位置，不放设左边为l，右边为r，然后再从r开始尽量往右找（尽量小），找到最后一个大于l的数m，交换m和l，这样将m换到l的位置后，不管l后面的数怎么变化，都比排列P要大，而我们想要的是大一个的排列，那我们就需要将l之后的排列的字母序设置为最小，也就是需要对l之后的数进行从小到大的排序。&lt;/p&gt;

&lt;p&gt;思想就是这样，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        for (int i = length-1 ; i &amp;gt;= 0 ; --i) {
            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;gt; nums[i-1]) {
                int j = i;
                while (j &amp;lt; nums.length &amp;amp;&amp;amp; nums[j] &amp;gt; nums[i-1]) ++j;
                --j;
                int temp = nums[j];
                nums[j] = nums[i-1];
                nums[i-1] = temp;
                sort(nums,i);
                return ;
            }
        }
        sort(nums,0);
    }
    public void sort(int[] nums, int index) {
        int start = index, end = nums.length -1;
        while(start&amp;lt;end) {
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度是O(n), 空间是O(1).&lt;/p&gt;

&lt;h3 id=&quot;permutation-sequence&quot;&gt;Permutation Sequence&lt;/h3&gt;

&lt;p&gt;The set [1,2,3,…,n] contains a total of n! unique permutations.&lt;/p&gt;

&lt;p&gt;By listing and labeling all of the permutations in order,&lt;/p&gt;

&lt;p&gt;We get the following sequence (ie, for n = 3):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given n and k, return the kth permutation sequence.&lt;/p&gt;

&lt;p&gt;Note: Given n will be between 1 and 9 inclusive.&lt;/p&gt;

&lt;p&gt;这道题是上一题的加强版，本题要求找到按字母序排序的第k个排列。&lt;/p&gt;

&lt;p&gt;比较暴力的解法是：利用前面的Next Permutation，从第一个排列开始，不断的往后找，直到找到第k个排列。这样的时间复杂度很大为O(kn), 我们需要一种O(n)的解法！&lt;/p&gt;

&lt;p&gt;我们可以利用不断定位的方式在O(n)时间内求解。&lt;/p&gt;

&lt;p&gt;m个数的排列有m!种，如果 (m-1)! &amp;lt; k &amp;lt;= m!我们就可以直接定位到第k个排列是从第几个数开始分析的，也就是说前面有n-m个数我们是可以确定的，他们就是1,2,3,…,n-m.&lt;/p&gt;

&lt;p&gt;定位到一个位置之后，我们可以算出k里面有多少个(m-1)!，假如有l个，然后选择后面的数中第l+1小的数放到此位置，然后令k = k - (m-1)! * l, 至此后面的问题就变成了一个子问题，我们可以用递归来解决，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// recursive method
// Directly locate the position by comparing k with i!
// Time complexity is O(n), space is O(n) since we used the recursive method.

public class Solution {
	public String getPermutation(int n, int k) {
		StringBuilder sb = new StringBuilder();
		List&amp;lt;Integer&amp;gt; nums = new LinkedList&amp;lt;Integer&amp;gt;();
		for (int i = 1; i &amp;lt;= n; ++i)
			nums.add(i);
		deal(nums, k, sb);
		return sb.toString();
	}

	public void deal(List&amp;lt;Integer&amp;gt; nums, int k, StringBuilder sb) {
		if (k == 1) {
			for (Integer in : nums)
				sb.append(in);
			return;
		}
		int mul = 1, i;
		for (i = 1; i &amp;lt;= nums.size(); ++i) {
			mul *= i;
			if (mul &amp;gt;= k)
				break;
		}
		int size = nums.size();
		for (int w = 0; w &amp;lt; size - i; ++w) {
			sb.append(nums.get(0));
			nums.remove(0);
		}
		if (mul == k) {
			for (int j = nums.size() - 1; j &amp;gt;= 0; --j)
				sb.append(nums.get(j));
			return;
		}
		mul /= i;
		int cur = k / mul;
		if (k % mul == 0) {
			sb.append(nums.get(cur-1));
			nums.remove(cur-1);
			for (int w = nums.size()-1; w &amp;gt;=0; --w)
				sb.append(nums.get(w));
			return;
		}
		sb.append(nums.get(cur));
		nums.remove(cur);
		deal(nums, k - cur * mul, sb);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法显得有些臃肿，我们可以用迭代来优化它，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String getPermutation(int n, int k) {
        List&amp;lt;Integer&amp;gt; num = new LinkedList&amp;lt;Integer&amp;gt;();
        for (int i = 1; i &amp;lt;= n; i++) num.add(i);
        int[] fact = new int[n];  // factorial
        fact[0] = 1;
        for (int i = 1; i &amp;lt; n; i++) fact[i] = i*fact[i-1];
        k = k-1;
        StringBuilder sb = new StringBuilder();
        for (int i = n; i &amp;gt; 0; i--){
            int ind = k/fact[i-1];
            k = k%fact[i-1];
            sb.append(num.get(ind));
            num.remove(ind);
        }
        return sb.toString();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，令k = k - 1， 可以避免对k = m!情况的特殊处理，需要细细品味！&lt;/p&gt;

&lt;p&gt;对于这种题，我们还可以引申一下：求出所有按字母序的排列？&lt;/p&gt;

&lt;p&gt;时间复杂度会如何呢？&lt;/p&gt;

&lt;p&gt;可以用递归求解，时间复杂度是O(n!).&lt;/p&gt;

&lt;h3 id=&quot;permutations--permutations-ii&quot;&gt;Permutations 和 Permutations II&lt;/h3&gt;

&lt;p&gt;两道题的区别主要是有没有重复的元素，题目大致如下：&lt;/p&gt;

&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

&lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;没有重复的分析&lt;/h4&gt;

&lt;p&gt;对于没有重复元素的情况，要产生全部排列，我们可以用子问题和迭代的方式：&lt;/p&gt;

&lt;p&gt;如果我们已经知道了n-1个元素的全部排列，那么求n个元素的排列，就可以利用n-1个元素排列的结果，&lt;/p&gt;

&lt;p&gt;方法是： 将第n个数分别插入到n-1个元素的每一个排列的每一个空隙中，每一种情况都唯一，不会重复，都是一个n个元素的排列。&lt;/p&gt;

&lt;p&gt;这种方法非常简单，时间复杂度是O(Σk!), 其中k从1到n。 代码不再写出，下面分析有重复元素的情况。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;有重复元素的解决办法&lt;/h4&gt;

&lt;p&gt;如果有重复元素，我们就不能像前面的方法那样随意的插入了，但是我们还是可以利用这个思想–利用之前m个元素的排列结果。&lt;/p&gt;

&lt;p&gt;首先我们需要将数组进行从小到大的排序，这样做的好处是让重复的元素都在一起，然后我们将数组看成一块一块的，每一块都是相同的元素，&lt;/p&gt;

&lt;p&gt;如果此时知道之前m个元素的所有排列，而当前的块有k个a，我们所要做的就是利用组合的方法将k个a插入到之前m个元素排列的每一种排列中去，这就变成了一个组合问题，&lt;/p&gt;

&lt;p&gt;那么如何插入呢?&lt;/p&gt;

&lt;p&gt;假如之前有一个排列是&lt;code&gt;1 2 3 4&lt;/code&gt; ， 现在有3个5要插入到里面， 做法就是求解将三个5插入到5个空位中的所有情况，&lt;/p&gt;

&lt;p&gt;组合问题的解决十分简单，就是利用递归和回溯，可以见后面的代码。&lt;/p&gt;

&lt;p&gt;这样按照相同块，不断的往后推，直到数组访问完，即可产生所有排列结果，总之，思想是迭代+组合。&lt;/p&gt;

&lt;p&gt;此方法也可以用于求解没有重复元素的情况。&lt;/p&gt;

&lt;p&gt;对于时间复杂度分析比较复杂，假设平均每块大小为m，有k块，则n = mk, 时间复杂度可以大致表示为O(n^m)(不太确定复杂度的计算)。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        result.add(new ArrayList&amp;lt;Integer&amp;gt;());
        Arrays.sort(nums);
        for (int i = 0 ; i &amp;lt; nums.length; ++i) {
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; temp = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
            int count = 1;
            int val = nums[i];
            while (i+1 &amp;lt; nums.length &amp;amp;&amp;amp; nums[i] == nums[i+1]) {
                i++;
                count++;
            }
            for (int j = 0 ; j &amp;lt; result.size(); ++j) {
                List&amp;lt;Integer&amp;gt; item = result.get(j);
                List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; new_items = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
                ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
                generate(item.size(),0,count,new_items,list);
                for (int k = 0; k &amp;lt; new_items.size(); ++k) {
                    ArrayList&amp;lt;Integer&amp;gt; locs = (ArrayList)new_items.get(k);
                    List&amp;lt;Integer&amp;gt; one = new ArrayList&amp;lt;Integer&amp;gt;(item);
                    for (int w = locs.size()-1; w &amp;gt;= 0 ; --w) {
                        one.add(locs.get(w),val);
                    }
                    temp.add(one);
                }
            }
            result = temp;
        }
        return result;
    }
    public void generate(int len, int index, int count, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; new_items, ArrayList&amp;lt;Integer&amp;gt; list) {
        for (int i = index; i &amp;lt;= len; ++i) {
            list.add(i);
            if (list.size() == count) {
                new_items.add((ArrayList)list.clone());
            }
            else {
                generate(len,i,count,new_items,list);
            }
            list.remove(list.size()-1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hombo.wang/leetcode/2015/06/02/Permutation</link>
                <guid>http://hombo.wang/leetcode/2015/06/02/Permutation</guid>
                <pubDate>2015-06-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spiral Matrix</title>
                <description>&lt;p&gt;对矩阵的访问花样很多，例如矩阵分别按行列排好序，然后进行查找；又比如矩阵的旋转，可以旋转90度，旋转180等等。而本题也很有趣，需要按顺时针螺旋的方式访问矩阵，并将1，2，3…..n^2，填入螺旋访问过程中的每个点。&lt;/p&gt;

&lt;p&gt;这个问题的关键在于如何实现螺旋遍历？&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;顺时针螺旋遍历的实现&lt;/h3&gt;

&lt;p&gt;遇到这种问题，我们可以从几个简单的例子中寻找规律：&lt;/p&gt;

&lt;p&gt;对于一个3×3的矩阵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 3
8 9 4
7 6 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到它会有2圈的回旋，&lt;/p&gt;

&lt;p&gt;对于一个4×4的矩阵，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1   2   3   4
12  13  14  5
11  16  15  6
10  9   8   7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会有2圈的回旋，&lt;/p&gt;

&lt;p&gt;而对于一个5×5的矩阵，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  20  11  10  9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会有3圈的回旋，&lt;/p&gt;

&lt;p&gt;如果继续下去，我们可以发现如果n为奇数，那么有&lt;code&gt;(n+1)/2&lt;/code&gt;次回旋，如果n为偶数，那么有&lt;code&gt;n/2&lt;/code&gt;次循环，因为n为偶数，所以&lt;code&gt;n/2 = (n+1)/2&lt;/code&gt;， 所以，对于n×n的矩阵，有&lt;code&gt;(n+1)/2&lt;/code&gt;次回旋。&lt;/p&gt;

&lt;p&gt;由此，我们已经找到规律，接下来就是实现了，我们只需要进行&lt;code&gt;(n+1)/2&lt;/code&gt;次操作，每次操作都是按顺时针访问一圈。&lt;/p&gt;

&lt;p&gt;如果我们定义当前访问的圈为第k圈，则我们可以很容易的定位这个圈的四个&lt;code&gt;角&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;左上 (k,k)
右上 (k,n-k-1)
左下 (n-k-1,k)
右下 (n-k-1,n-k-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面的操作就很简单了，就是按顺时针的顺序，遍历这四个点标示的行和列，但是需要注意的是不能够重复遍历相同的位置。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public int[][] generateMatrix(int n) {
        int[][] spiral = new int[n][n];
        int val = 1;
        for (int k = 0; k &amp;lt; (n+1)/2; ++k) {
            for (int i = k; i &amp;lt; n-k; ++i) {
                spiral[k][i] = val++;
            }
            for (int i = k+1; i &amp;lt; n-k; ++i) {
                spiral[i][n-k-1] = val++;
            }
            for (int i = n-k-2; i &amp;gt;= k &amp;amp;&amp;amp; k &amp;lt; n-k-1; --i) {
                spiral[n-k-1][i] = val++;
            }
            for (int i = n-k-2; i &amp;gt;= k+1 &amp;amp;&amp;amp; k &amp;lt; n-k-1; --i) {
                spiral[i][k] = val++;
            }
        }
        return spiral;
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2015/06/01/Spiral-Matrix</link>
                <guid>http://hombo.wang/leetcode/2015/06/01/Spiral-Matrix</guid>
                <pubDate>2015-06-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Merge Intervals</title>
                <description>&lt;p&gt;Leetcode 上面有两道关于数轴区间重合和归并的问题：Merge Intervals 和 Insert Interval。两道题大同小异，可以用类似的方法求解。主要问题是如何区分两段区间是否重合，和采用哪种方式进行归并，要求效率要高。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;如何判断数轴上两段区间是否重合？&lt;/h3&gt;

&lt;p&gt;猛一看此问题比较棘手，情况比较多，但是如果能换一个角度思考，问题就迎刃而解。我们可以采用逆向思维，判断两段区间重合也就是判断两段区间不重合的反命题，两段区间不重合非常容易判断，假设两区间：[a,b]和[c,d]，他们不重合的条件是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b &amp;lt; c || a &amp;gt; d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们可以很容易得出他们重合的条件是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!(b &amp;lt; c || a &amp;gt; d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步，如果两段区间是按照开始端点从小到大排好序的，即有，a &amp;lt;= c，那么我们还可以把判断重合的条件进一步精简为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!(b &amp;lt; c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个条件就是我们后面解决这两道题目时所用到的。&lt;/p&gt;

&lt;h3 id=&quot;merge-intervals&quot;&gt;Merge Intervals&lt;/h3&gt;

&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Given [1,3],[2,6],[8,10],[15,18],&lt;/p&gt;

&lt;p&gt;return [1,6],[8,10],[15,18].&lt;/p&gt;

&lt;p&gt;这道题目就是需要把所有重叠的区间归并成一个，然后给出最后所有不重叠的区间。&lt;/p&gt;

&lt;h4 id=&quot;on2&quot;&gt;O(n^2)解法&lt;/h4&gt;

&lt;p&gt;首先我们可以想到的是从第一区间开始，不断的往后找和它重叠的区间，然后合并，把合并的结果存到第一个区间中，并把其他区间删除，然后在从第一个区间开始重复找，如果找不到重叠的区间，就加入结果列表，并从第二个区间开始继续之前的操作，从而找到所有结果。&lt;/p&gt;

&lt;p&gt;这种解法效率低，其实有更好的解法。&lt;/p&gt;

&lt;h4 id=&quot;onlogn&quot;&gt;O(nlogn)解法&lt;/h4&gt;

&lt;p&gt;如果我们吧所有区间都按开始点从小到大排好序，那么我们就可以采用不断扩大区间结尾的方法来归并所有区间，这样我们只需要扫描一遍排好序后的列表即可，时间是O(n)， 但是我们的排序复杂度是O(nlogn)， 因此整体的复杂度是O(nlogn).
实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public List&amp;lt;Interval&amp;gt; merge(List&amp;lt;Interval&amp;gt; intervals) {
        Collections.sort(intervals, new Comparator&amp;lt;Interval&amp;gt;(){
            @Override
            public int compare(Interval obj0, Interval obj1) {
                return obj0.start - obj1.start;
            }
        });

        List&amp;lt;Interval&amp;gt; ret = new ArrayList&amp;lt;&amp;gt;();
        Interval prev = null;
        for (Interval inter : intervals) {
            if (  prev==null || inter.start&amp;gt;prev.end ) {
                ret.add(inter);
                prev = inter;
            } else if (inter.end&amp;gt;prev.end) {
                // Modify the element already in list
                prev.end = inter.end;
            }
        }
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中利用Collections的sort函数，并实现了Comparator接口来自定义排序。&lt;/p&gt;

&lt;h3 id=&quot;insert-intervals&quot;&gt;Insert Intervals&lt;/h3&gt;

&lt;p&gt;Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).&lt;/p&gt;

&lt;p&gt;You may assume that the intervals were initially sorted according to their start times.&lt;/p&gt;

&lt;p&gt;Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].&lt;/p&gt;

&lt;p&gt;Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].&lt;/p&gt;

&lt;p&gt;This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;解法：&lt;/h4&gt;

&lt;p&gt;这道题和Merge Intervals 大同小异，它已经实现了按起始点排序，我们就不需要在操作了，我们需要的是把newInterval按序插入到列表中，后面的操作就是Merge Intervals一模一样了，时间复杂度是O(n)，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public List&amp;lt;Interval&amp;gt; insert(List&amp;lt;Interval&amp;gt; intervals, Interval newInterval) {
        List&amp;lt;Interval&amp;gt; result = new ArrayList&amp;lt;Interval&amp;gt;();
        int i = 0, size = intervals.size();
        for (; i &amp;lt; size; ++i) {
            if (intervals.get(i).start &amp;gt;= newInterval.start) {
                intervals.add(i,newInterval);
                break;
            }
        }
        if (i == size) 
            intervals.add(newInterval);
        Interval pre = null;
        for (i = 0; i &amp;lt; intervals.size(); ++i) {
            Interval cur = intervals.get(i);
            if (pre == null || cur.start &amp;gt; pre.end) {
                result.add(cur);
                pre = cur;
            }
            else {
                pre.end = Math.max(pre.end,cur.end);
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hombo.wang/leetcode/2015/06/01/Merge-Intervals</link>
                <guid>http://hombo.wang/leetcode/2015/06/01/Merge-Intervals</guid>
                <pubDate>2015-06-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Maximum Subarray</title>
                <description>&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array [−2,1,−3,4,−1,2,1,−5,4],&lt;/p&gt;

&lt;p&gt;the contiguous subarray [4,−1,2,1] has the largest sum = 6.&lt;/p&gt;

&lt;p&gt;非常经典的一道题–连续字段和。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;one-pass&quot;&gt;解法一：ONE PASS&lt;/h3&gt;

&lt;p&gt;用一个&lt;code&gt;sum&lt;/code&gt;保存当前连续的字段和，如果当前访问的值是一个&lt;code&gt;小于零&lt;/code&gt;的数，我们就&lt;code&gt;当前的字段和sum&lt;/code&gt;和最优值&lt;code&gt;max&lt;/code&gt;进行比较, 进行一次最优值的更新。如果当前&lt;code&gt;sum+当前值&lt;/code&gt;小于零，就没有必要更新sum值了，直接令&lt;code&gt;sum=0&lt;/code&gt;， 也就是说前面连续的字段和已经小于零，给后面的过程增加不了&lt;code&gt;收益&lt;/code&gt;，反之，如果&lt;code&gt;sum+当前值 &amp;gt;= 0&lt;/code&gt;，就可以更新&lt;code&gt;sum = sum + 当前值&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// pass once 
// We should be careful with the case when all the elements are negatives.
// Time is O(n), space is O(1).
public class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0, biggest = Integer.MIN_VALUE, count = 0;;
        for (int i = 0; i &amp;lt; nums.length; ++i) {
            if (nums[i] &amp;lt; 0) {
                max = Math.max(max,sum);
                biggest = Math.max(nums[i],biggest);
                count++;
            }
            sum += nums[i];
            if (sum &amp;lt; 0) {
                sum = 0;
            }
        }
        if (count == nums.length)
            return biggest;
        return Math.max(max,sum);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码还可以简化，但是需要在每个点都判断和更新max值，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A simpler solution
// Also one pass
public class Solution {
    public int maxSubArray(int[] nums) {
        int curSum = nums[0], maxSum = nums[0];
        for (int i = 1; i &amp;lt; nums.length; ++i) {
            curSum = Math.max(curSum+nums[i], nums[i]);
            maxSum = Math.max(curSum, maxSum);
        }
        return maxSum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;dp&quot;&gt;解法二：DP&lt;/h3&gt;

&lt;p&gt;其实本题也可以用dp来解决，令dp(i)表示从0到i，以i为结尾的最大连续字段和。
递推公式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dp[i] = num[i] + max{dp[i-1],0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面的公式可以很容易求出每个点的dp[i]， 然后所有点的dp[i]的最大值就是解，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int maxSubArray(int[] A) {
        int n = A.length;
        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];
        dp[0] = A[0];
        int max = dp[0];
        for(int i = 1; i &amp;lt; n; i++){
            dp[i] = A[i] + (dp[i - 1] &amp;gt; 0 ? dp[i - 1] : 0);
            max = Math.max(max, dp[i]);
        }
        return max;
} 
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://hombo.wang/leetcode/2015/05/29/Maximum_Subarray</link>
                <guid>http://hombo.wang/leetcode/2015/05/29/Maximum_Subarray</guid>
                <pubDate>2015-05-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Android中关于图片压缩、截图、旋转的一些方法</title>
                <description>&lt;p&gt;最近做项目使用到了图片的各种处理，遇到了各种问题，经过研究和调试，在此总结一些关于图片处理的方法，以便今后使用。这些方法包括图片压缩、bitmap缩略图、图片旋转和截图。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 图片压缩&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	// /图片压缩
	public static Bitmap compressImage(Bitmap image) {

		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		image.compress(Bitmap.CompressFormat.JPEG, 90, baos);
		int options = 90;
		while (baos.toByteArray().length / 1024 &amp;gt; 100) { // 循环判断如果压缩后图片是否大于100kb,大于继续压缩
			baos.reset();// 重置baos即清空baos
			image.compress(Bitmap.CompressFormat.JPEG, options, baos);// 这里压缩options%，把压缩后的数据存放到baos中
			options -= 10;// 每次都减少10
		}
		ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());// 把压缩后的数据baos存放到ByteArrayInputStream中
		Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);// 把ByteArrayInputStream数据生成图片
		return bitmap;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bitmap&quot;&gt;2. 从图片文件产生Bitmap缩略图&lt;/h3&gt;

&lt;p&gt;有时候图片文件很大，加载到Bitmap，然后放置到控件上会发生OOM（内存溢出）错误，下面的方法通过先压缩的方式，避免了这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Bitmap compressBitmap(String filepath, Context context) {
	BitmapFactory.Options opt = new BitmapFactory.Options();
	opt.inJustDecodeBounds = true;
	Bitmap bm = BitmapFactory.decodeFile(filepath, opt);

	// 获取到这个图片的原始宽度和高度
	int picHeight = opt.outHeight;

	// 获取屏的宽度和高度
	WindowManager windowManager = ((Activity) context).getWindowManager();
	Display display = windowManager.getDefaultDisplay();
	int screenHeight = display.getHeight();

	int scale = picHeight/80;
	
	if (scale &amp;lt;= 0) {
		scale = 1;
	}
	opt.inSampleSize = scale;
	// 这次再真正地生成一个有像素的，经过缩放了的bitmap

	opt.inJustDecodeBounds = false;
	bm = BitmapFactory.decodeFile(filepath, opt);
	return bm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3. 图片旋转调整&lt;/h3&gt;

&lt;p&gt;有时候拍照后图片存储的方向不对，下面的两个方法可以对图片进行调整归正：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 通过ExifInterface类读取图片文件的被旋转角度
 * 
 * @param path
 *            ： 图片文件的路径
 * @return 图片文件的被旋转角度
 */
public static int readPicDegree(String path) {
	int degree = 0;

	// 读取图片文件信息的类ExifInterface
	ExifInterface exif = null;
	try {
		exif = new ExifInterface(path);
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}

	if (exif != null) {
		int orientation = exif.getAttributeInt(
				ExifInterface.TAG_ORIENTATION,
				ExifInterface.ORIENTATION_NORMAL);
		switch (orientation) {
		case ExifInterface.ORIENTATION_ROTATE_90:
			degree = 90;
			break;

		case ExifInterface.ORIENTATION_ROTATE_180:
			degree = 180;
			break;

		case ExifInterface.ORIENTATION_ROTATE_270:
			degree = 270;
			break;
		}
	}

	return degree;
}

/**
 * 将图片纠正到正确方向
 * 
 * @param degree
 *            ： 图片被系统旋转的角度
 * @param bitmap
 *            ： 需纠正方向的图片
 * @return 纠向后的图片
 */
public static Bitmap rotateBitmap(int degree, Bitmap bitmap) {
	Matrix matrix = new Matrix();
	matrix.postRotate(degree);

	Bitmap bm = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
			bitmap.getHeight(), matrix, true);
	return bm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;4. 图片剪裁&lt;/h3&gt;

&lt;p&gt;下面这个方法会遍历系统的剪裁工具，然后实现图片的剪裁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void doCrop(Uri uri) {
	final ArrayList&amp;lt;CropOption&amp;gt; cropOptions = new ArrayList&amp;lt;CropOption&amp;gt;();

	Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);
	intent.setType(&quot;image/*&quot;);

	List&amp;lt;ResolveInfo&amp;gt; list = getPackageManager().queryIntentActivities(
			intent, 0);

	int size = list.size();

	if (size == 0) {
		Toast.makeText(this, &quot;Can not find image crop app&quot;,
				Toast.LENGTH_SHORT).show();
		return;
	} else {
		intent.setData(uri);

        //剪裁的分辨率和长宽比
		intent.putExtra(&quot;outputX&quot;, 300);
		intent.putExtra(&quot;outputY&quot;, 300);
		intent.putExtra(&quot;aspectX&quot;, 1);
		intent.putExtra(&quot;aspectY&quot;, 1);
		
		intent.putExtra(&quot;scale&quot;, true);
		intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detection
		intent.putExtra(&quot;return-data&quot;, false);
		intent.putExtra(MediaStore.EXTRA_OUTPUT,
				Uri.fromFile(new File(Environment
						.getExternalStorageDirectory(), filename[index])));
		intent.putExtra(&quot;outputFormat&quot;,
				Bitmap.CompressFormat.JPEG.toString());

		if (size == 1) {
			Intent i = new Intent(intent);
			ResolveInfo res = list.get(0);

			i.setComponent(new ComponentName(res.activityInfo.packageName,
					res.activityInfo.name));

			startActivityForResult(i, CROP_FROM_CAMERA);
		} else {
			for (ResolveInfo res : list) {
				final CropOption co = new CropOption();

				co.title = getPackageManager().getApplicationLabel(
						res.activityInfo.applicationInfo);
				co.icon = getPackageManager().getApplicationIcon(
						res.activityInfo.applicationInfo);
				co.appIntent = new Intent(intent);

				co.appIntent
						.setComponent(new ComponentName(
								res.activityInfo.packageName,
								res.activityInfo.name));

				cropOptions.add(co);
			}

			CropOptionAdapter adapter = new CropOptionAdapter(
					getApplicationContext(), cropOptions);

			AlertDialog.Builder builder = new AlertDialog.Builder(this);
			builder.setTitle(&quot;Choose Crop App&quot;);
			builder.setAdapter(adapter,
					new DialogInterface.OnClickListener() {
						public void onClick(DialogInterface dialog, int item) {
							startActivityForResult(
									cropOptions.get(item).appIntent,
									CROP_FROM_CAMERA);
						}
					});

			builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
				@Override
				public void onCancel(DialogInterface dialog) {

					if (mImageCaptureUri[index] != null) {
						getContentResolver().delete(
								mImageCaptureUri[index], null, null);
						mImageCaptureUri[index] = null;
					}
				}
			});

			AlertDialog alert = builder.create();

			alert.show();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/android/2015/03/12/Android-about-pictures</link>
                <guid>http://hombo.wang/android/2015/03/12/Android-about-pictures</guid>
                <pubDate>2015-03-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java 八种基本数据类型的表示范围</title>
                <description>&lt;p&gt;Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。这几种基本类型的表示范围容易混淆，例如int和long的表示范围。下面对着八种类型进行区分：&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;byte&quot;&gt;byte&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· byte数据类型是8位、有符号的，以二进制补码表示的整数；
· 最小值是-128（-2^7）；
· 最大值是127（2^7-1）；
· 默认值是0；
· byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；
  例子：byte a = 100，byte b = -50。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;short&quot;&gt;short&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· short数据类型是16位、有符号的以二进制补码表示的整数
· 最小值是-32768（-2^15）；
· 最大值是32767（2^15 - 1）；
· Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；
· 默认值是0；
· 例子：short s = 1000，short r = -20000。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;int&quot;&gt;int&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· int数据类型是32位、有符号的以二进制补码表示的整数；
· 最小值是-2,147,483,648（-2^31）；
· 最大值是2,147,485,647（2^31 - 1）；
· 一般地整型变量默认为int类型；
· 默认值是0；
· 例子：int a = 100000, int b = -200000。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;long&quot;&gt;long&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· long数据类型是64位、有符号的以二进制补码表示的整数；
· 最小值是-9,223,372,036,854,775,808（-2^63）；
· 最大值是9,223,372,036,854,775,807（2^63 -1）；
· 这种类型主要使用在需要比较大整数的系统上；
· 默认值是0L；
· 例子： long a = 100000L，int b = -200000L。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;float&quot;&gt;float&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· float数据类型是单精度、32位、符合IEEE 754标准的浮点数；
· float在储存大型浮点数组的时候可节省内存空间；
· 默认值是0.0f；
· 浮点数不能用来表示精确的值，如货币；
· 例子：float f1 = 234.5f。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;double&quot;&gt;double&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· double数据类型是双精度、64位、符合IEEE 754标准的浮点数；
· 浮点数的默认类型为double类型；
· double类型同样不能表示精确的值，如货币；
· 默认值是0.0f；
· 例子：double d1 = 123.4。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;boolean&quot;&gt;boolean&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· boolean数据类型表示一位的信息；
· 只有两个取值：true和false；
· 这种类型只作为一种标志来记录true/false情况；
· 默认值是false；
· 例子：boolean one = true。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;char&quot;&gt;char&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;· char类型是一个单一的16位Unicode字符；
· 最小值是’\u0000’（即为0）；
· 最大值是’\uffff’（即为65,535）；
· char数据类型可以储存任何字符；
· 例子：char letter = ‘A’。
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/java/2015/03/10/Java-base-type-range</link>
                <guid>http://hombo.wang/java/2015/03/10/Java-base-type-range</guid>
                <pubDate>2015-03-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Latex中加入空格</title>
                <description>&lt;p&gt;Latex中的空格符” “在编译的过程中会被忽略，在做自己简历的过程中，遇到了两种需要加空格的情况：一种是在句子中间加空格，另一种是在行首加空格，下面记录一下这两种加空格的方法。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;句子中的空格&lt;/h3&gt;

&lt;p&gt;方法很简单，就是用”\ “来表示一个空格，需要多少空格就加多少个”\ “，需要注意的是连续的两个‘\’表示的是回车换行（“\”），下面举一个代码例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\cvitem{2013.9--2016.7}{\ \ \ 中国科学院\ \ \ \ \ \ \ 计算技术研究所\ \ \ \ \ \ \ \ \ \ \ \ \ 硕士} 
\cvitem{2009.9--2013.7}{\ \ \ 华中科技大学\ \ \ \ 计算机科学与技术学院\ \ \  \ 学士}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;行首的空格&lt;/h3&gt;

&lt;p&gt;行首不能直接用上面的方法来加入空格，因为也会被编译器忽略掉，在行首加入空格的方式是用&lt;code&gt;\hspace&lt;/code&gt;，举个列子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\cvitem{2013.9--2016.7}{\ \ \ 中国科学院\ \ \ \ \ \ \ 计算技术研究所\ \ \ \ \ \ \ \ \ \ \ \ \ 硕士} 
\cvitem{2009.9--2013.7}{\ \ \ 华中科技大学\ \ \ \ 计算机科学与技术学院\ \ \  \ 学士}
\hspace{19ex}{GPA:  3.91\ \ \ \ \ \ \ \ \ 年级排名:  4/350} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;其它加空格的方法&lt;/h3&gt;

&lt;p&gt;下面是一些加空格的方法的总结：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\documentclass{article}
\begin{document}

\noindent
There are a number of horizontal spacing macros for LaTeX:

\noindent\begin{tabular}{lp{5cm}}
  \verb|a\,b| &amp;amp; a\,b \\
  \verb|$a\,b$| &amp;amp; $a\,b$ \\
  \verb|a\thinspace b| &amp;amp; a\thinspace b \\
  \verb|$a\thinspace b$| &amp;amp; $a\thinspace b$ \\
  \verb|$a\!b$| &amp;amp; $a\!b$ \\
  \verb|$a\mkern-\thinmuskip b$| &amp;amp; $a\mkern-\thinmuskip b$ \\
  \verb|$a\&amp;gt;b$| &amp;amp; $a\&amp;gt;b$ \\
  \verb|$a\mkern\medmuskip b$| &amp;amp; $a\mkern\medmuskip b$ \\
  \verb|$a\;b$| &amp;amp; $a\;b$ \\
  \verb|$a\mkern\thickmuskip b$| &amp;amp; $a\mkern\thickmuskip b$ \\
  \verb|$a\:b$| &amp;amp; $a\:b$ \\
  \verb|$a\mkern\medmuskip b$| &amp;amp; $a\mkern\medmuskip b$ \\
  \verb|a\enspace b| &amp;amp; a\enspace b \\
  \verb|$a\enspace b$| &amp;amp; $a\enspace b$ \\
  \verb|a\quad b| &amp;amp; a\quad b \\
  \verb|$a\quad b$| &amp;amp; $a\quad b$ \\
  \verb|a\qquad b| &amp;amp; a\qquad b \\
  \verb|$a\qquad b$| &amp;amp; $a\qquad b$ \\
  \verb|a\hskip 1em b| &amp;amp; a\hskip 1em b \\
  \verb|$a\hskip 1em b$| &amp;amp; $a\hskip 1em b$ \\
  \verb|a\kern 1pc b| &amp;amp; a\kern 1pc b \\
  \verb|$a\kern 1pc b$| &amp;amp; $a\kern 1pc b$ \\
  \verb|a\hspace{35pt}b| &amp;amp; a\hspace{35pt}b \\
  \verb|$a\hspace{35pt}b$| &amp;amp; $a\hspace{35pt}b$ \\
  \verb|axyzb| &amp;amp; axyzb \\
  \verb|a\hphantom{xyz}b| &amp;amp; a\hphantom{xyz}b \\
  \verb|$axyzb$| &amp;amp; $axyzb$ \\
  \verb|$a\hphantom{xyz}b$| &amp;amp; $a\hphantom{xyz}b$ \\
  \verb|a\ b| &amp;amp; a\ b \\
  \verb|$a\ b$| &amp;amp; $a\ b$ \\
  \verb|a~b| &amp;amp; a~b \\
  \verb|$a~b$| &amp;amp; $a~b$ \\
  \verb|a\hfill b| &amp;amp; a\hfill b \\
  \verb|$a\hfill b$| &amp;amp; $a\hfill b$
\end{tabular}
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下图：
&lt;img src=&quot;http://i.stack.imgur.com/BQKUF.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
                <link>http://hombo.wang/latex/2015/03/09/Latex-Spacing</link>
                <guid>http://hombo.wang/latex/2015/03/09/Latex-Spacing</guid>
                <pubDate>2015-03-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在onCreate中获取控件尺寸的方法</title>
                <description>&lt;p&gt;我们知道在activity绘制完成之后，获取控件尺寸的方式就是调用getWitdh和getHeight，但是在onCreate中调用这两个方法，获取到的宽高不正确，为0，这是因为，在调用oncreate()方法时，界面处于不可见状态，内存加载组件还没有绘制出来，你是无法获取它的尺寸。那怎么在onCreate中获取控件的大小呢？有下面三个方法：&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;section&quot;&gt;方法一&lt;/h4&gt;

&lt;p&gt;在onCreate中加入对控件的测量代码，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int w = View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); 
int h = View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); 
imageView.measure(w, h); 
int height =imageView.getMeasuredHeight(); 
int width =imageView.getMeasuredWidth(); 
textView.append(&quot;\n&quot;+height+&quot;,&quot;+width);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这中方法可以获取到空间大小，但是获取的值有时候不太准确。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;方法二&lt;/h4&gt;

&lt;p&gt;在onCreate中加入对整体布局的监听，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewTreeObserver vto2 = imageView.getViewTreeObserver();   
vto2.addOnGlobalLayoutListener(new OnGlobalLayoutListener() { 
    @Override   
    public void onGlobalLayout() { 
        imageView.getViewTreeObserver().removeGlobalOnLayoutListener(this);   
        textView.append(&quot;\n\n&quot;+imageView.getHeight()+&quot;,&quot;+imageView.getWidth()); 
    }   
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法和方法一一样，有时候获取到的大小不太准确。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;方法三（准确方法）&lt;/h4&gt;

&lt;p&gt;最准确获得控件大小的方式就是在onStart中加入绘制控件之前的监听，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewTreeObserver vto = imageView.getViewTreeObserver(); 
vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { 
    public boolean onPreDraw() { 
        int height = imageView.getMeasuredHeight(); 
        int width = imageView.getMeasuredWidth(); 
        textView.append(&quot;\n&quot;+height+&quot;,&quot;+width); 
        return true; 
    } 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法，我是实验了好久，才找到的，这是目前最好的获取控件尺寸大小的方法了！&lt;/p&gt;

</description>
                <link>http://hombo.wang/android/2015/03/08/Android-Get-View-Size-In-onCreate</link>
                <guid>http://hombo.wang/android/2015/03/08/Android-Get-View-Size-In-onCreate</guid>
                <pubDate>2015-03-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Volley duplicated post with slow request</title>
                <description>&lt;p&gt;最近做一个android的项目，遇到一个比较奇怪的问题：使用volley框架向服务器post几张图片，也就是图片的上传，当图片比较多或者比较大的时候，发现会触发好多次相同的post，现在记录一下问题的原因和解决方法。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;post&quot;&gt;出现多次post的原因&lt;/h4&gt;
&lt;p&gt;volley的post有两个超时时间，一个是retry的阈值时间t1，一个是post的超时时间timeout，当post的超时时间timeout大于retry的阈值时间时，就会产生这种想象，也就是在第一个post由于传输量比较大而没有完成之前，产生了retry，也就会产生额外的post。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;解决方法1&lt;/h4&gt;
&lt;p&gt;既然retry会造成这种错误，在传输量比较大的时候，我们干脆就不用retry，禁止掉retry的方式是设置retry的阈值为0，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	postRequest.setRetryPolicy(new DefaultRetryPolicy(
			0, //设置retry的时间阈值
			DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
			DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式简单，但是禁止retry对功能上会产生一定的影响。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;解决方法2&lt;/h4&gt;
&lt;p&gt;修改retry的阈值时间，使它大于post的timeout时间，这种方式比较合理，一般的设置方法是将retry的阈值时间扩大到默认时间的k倍，k值视具体情况而定。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	postRequest.setRetryPolicy(new DefaultRetryPolicy(
			DefaultRetryPolicy.DEFAULT_TIMEOUT_MS * k,
			DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
			DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/android/2015/03/05/Volley-duplicated-post-with-slow-request</link>
                <guid>http://hombo.wang/android/2015/03/05/Volley-duplicated-post-with-slow-request</guid>
                <pubDate>2015-03-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Fix the appcompat_v7 missing problem</title>
                <description>&lt;p&gt;在升级了最新版的android ADT后，发现每次建立一个工程都会多出一个appcompat_v7的工程，很是奇怪，今天不小心把这个工程删除了，然后自己的工程就各种报错误，仔细看看错误一般是关于资源的，这是因为一些文件中用到appcompat_v7的一些资源，下面来说明如何更正这些文件，从而摆脱appcompat_v7。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;section&quot;&gt;第一步&lt;/h4&gt;
&lt;p&gt;到工程的Properties中的Android项中，把Library中的关于appcompat_v7的引用remove掉。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.stack.imgur.com/ncXPr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后再将appcompat_v7工程给删除掉，这时你的工程会出现一些R资源未定义的错误，接下来的三步可以纠正这个错误。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;第二步&lt;/h4&gt;
&lt;p&gt;打开你的工程的res/values/styles.xml文件，将其中的&lt;code&gt;AppBaseTheme&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;由&lt;code&gt;Theme.AppCompat.Light&lt;/code&gt; 改为&lt;code&gt;@android:style/Theme.Light&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;第三步&lt;/h4&gt;
&lt;p&gt;打开工程的res/values-v11/styles.xml文件，将其中的&lt;code&gt;AppBaseTheme&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;由&lt;code&gt;Theme.AppCompat.Light&lt;/code&gt;改为&lt;code&gt;@android:style/Theme.Holo.Light&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;第四步&lt;/h4&gt;
&lt;p&gt;打开工程的rest/values-v14/styles.xml文件，将&lt;code&gt;AppBaseTheme&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;由&lt;code&gt;Theme.AppCompat.Light.DarkActionBar&lt;/code&gt;改为&lt;code&gt;@android:style/Theme.Holo.Light.DarkActionBar&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样，在完成了一起上四个步骤后，就可以删除appcompat_v7了，重新编译自己的工程，应该可以正常运行。&lt;/p&gt;

</description>
                <link>http://hombo.wang/android/2014/12/29/appcompat_v7-missing-problem</link>
                <guid>http://hombo.wang/android/2014/12/29/appcompat_v7-missing-problem</guid>
                <pubDate>2014-12-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Tabhost enable onResume</title>
                <description>&lt;p&gt;我们知道tabhost包含的子activiy的生命周期和正常的activity的生命周期不太一样，tabhost中的activiy屏蔽掉了onResume()，onPause()等方法，那怎么让这些方法去除屏蔽呢，下面的例子，显示了使能onResume和onPause的方式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;localactivitymanager&quot;&gt;重点是利用LocalActivityManager&lt;/h4&gt;
&lt;p&gt;在tabhost的主activity中建立一个LocalActivityManager变量，然后重写onResume()，onPause()两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onResume() {
	super.onResume();
	mLocalActivityManager.dispatchResume();
}

@Override
protected void onPause() {
	super.onPause();
	mLocalActivityManager.dispatchPause(isFinishing());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在onResume中调用LocalActiviManager的dispatchResume()方法，在onPause中调用LocalActiviManager的dispatchPause()方法，然后在切换tab时，调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mLocalActivityManager.dispatchPause(isFinishing());
mLocalActivityManager.dispatchResume();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以让子activiy的onResume()，onPause()使能。&lt;/p&gt;

&lt;p&gt;具体实例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  tabhost enable onResume and onPause
 
package com.example.ikteacher.activity;

import com.example.ikteacher.R;
import com.example.ikteacher.R.anim;
import com.example.ikteacher.R.id;
import com.example.ikteacher.R.layout;

import android.app.Activity;
import android.app.LocalActivityManager;
import android.app.TabActivity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TabHost;

public class HomeInteractActivity extends TabActivity {

	TabHost tabHost;

	ImageButton btn_tab_message, btn_tab_contacts;
	ImageButton btn_title_back, btn_tile_add;
	LocalActivityManager mLocalActivityManager;

	@SuppressWarnings(&quot;deprecation&quot;)
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_home_interact);
		
		mLocalActivityManager = new LocalActivityManager(this, false);

		btn_title_back = (ImageButton) findViewById(R.id.btn_title_back);
		btn_title_back.setOnClickListener(new Button.OnClickListener() {

			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				HomeInteractActivity.this.finish();
			}
		});

		btn_tab_message = (ImageButton) findViewById(R.id.btn_tab_message);
		btn_tab_contacts = (ImageButton) findViewById(R.id.btn_tab_contacts);

		btn_tab_message.setSelected(true);
		
		tabHost = getTabHost();
		tabHost.addTab(tabHost.newTabSpec(&quot;message&quot;).setIndicator(&quot;Message&quot;)
				.setContent(new Intent(this, MessageActivity.class).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)));
		tabHost.addTab(tabHost.newTabSpec(&quot;contacts&quot;).setIndicator(&quot;Contacts&quot;)
				.setContent(new Intent(this, ContactsActivity.class)));

		tabHost.setCurrentTabByTag(&quot;message&quot;);
	}

	/**
	 * tab点击事件
	 * 
	 * @param view
	 */
	public void onTabClicked(View view) {
		switch (view.getId()) {
		case R.id.btn_tab_message:
			btn_tab_contacts.setSelected(false);
			btn_tab_message.setSelected(true);
			tabHost.setCurrentTabByTag(&quot;message&quot;);
			mLocalActivityManager.dispatchPause(isFinishing());
			mLocalActivityManager.dispatchResume();
			break;
		case R.id.btn_tab_contacts:
			btn_tab_message.setSelected(false);
			btn_tab_contacts.setSelected(true);
			tabHost.setCurrentTabByTag(&quot;contacts&quot;);
			mLocalActivityManager.dispatchPause(isFinishing());
			mLocalActivityManager.dispatchResume();
			break;
		}
	}

	@Override
	public void finish() {
		// TODO Auto-generated method stub
		super.finish();
		this.overridePendingTransition(R.anim.in_from_left, R.anim.out_to_right);
	}
	
	@SuppressWarnings(&quot;deprecation&quot;)
	@Override
    protected void onResume() {
		super.onResume();
		mLocalActivityManager.dispatchResume();
    }

    @Override
    protected void onPause() {
    	super.onPause();
    	mLocalActivityManager.dispatchPause(isFinishing());
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/android/2014/12/28/TabhostActivity-Enable-onResume</link>
                <guid>http://hombo.wang/android/2014/12/28/TabhostActivity-Enable-onResume</guid>
                <pubDate>2014-12-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>RoundedNetworkImageView</title>
                <description>&lt;p&gt;将Volley的NetworkImageView的方形显示图片改为圆形显示，方法非常好，在此记录一下代码，方便自己和其他人今后使用！&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;imageviewondrawgetcroppedbitmap&quot;&gt;将方形改成圆形的核心思想是重写ImageView的onDraw和getCroppedBitmap两个方法。&lt;/h4&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  RoundedNetworkImageView
 
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Shader;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
 
import com.android.volley.toolbox.NetworkImageView;
 
 
public class RoundedNetworkImageView extends NetworkImageView {
    private int borderColor = 0xffffffff;
    private int borderWidth = 10;
 
    public RoundedNetworkImageView(Context context) {
        super(context);
    }
 
    public RoundedNetworkImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
 
    public RoundedNetworkImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }
 
    public void setBorderColor(int resourceID) {
        borderColor = resourceID;
    }
 
    public void setBorderWidth(int border) {
        borderWidth = border;
    }
 
    public int getBorderWidth() {
        return borderWidth;
    }
 
    @Override
    protected void onDraw(Canvas canvas) {
        Drawable drawable = getDrawable();
 
        if (drawable == null || getWidth() == 0 || getHeight() == 0)
            return;
 
        Bitmap b = ((BitmapDrawable) drawable).getBitmap();
        if (b != null) {
            Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888, true);
 
            int radius = (getWidth() &amp;lt; getHeight()) ? getWidth() / 2 : getHeight() / 2;
 
            Bitmap roundBitmap = getCroppedBitmap(bitmap, radius);
            canvas.drawBitmap(roundBitmap, 0, 0, null);
        }
    }
 
    public Bitmap getCroppedBitmap(Bitmap bmp, int radius) {
        Bitmap scaledBmp = Bitmap.createScaledBitmap(bmp, radius * 2, radius * 2, false);
        Bitmap output = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(output);
 
        final Paint paint = new Paint();
 
        paint.setAntiAlias(true);
        paint.setFilterBitmap(true);
        paint.setDither(true);
        canvas.drawARGB(0, 0, 0, 0);
 
        // Draws a circle to create the border
        paint.setColor(borderColor);
        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, paint);
 
        // Draws the image subtracting the border width
        BitmapShader s = new BitmapShader(scaledBmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
        paint.setShader(s);
        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius - borderWidth - 0.5f, paint);
 
        return output;
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/android/2014/12/26/RoundedNetWorkImageView</link>
                <guid>http://hombo.wang/android/2014/12/26/RoundedNetWorkImageView</guid>
                <pubDate>2014-12-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode Unique Binary Search Trees</title>
                <description>&lt;p&gt;这道题是一道关于BST树的问题，也就是二叉排序树，题目的意思是给出n个结点，每个结点的值从1到n，问这n个结点组成的二叉排序树有多少种？题目其实不难，用dp可以在O(n^2)下解决，但这里有一个更快的的方法——卡特兰数（Catalan number）。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1         3     3      2      1
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;这道题是一道组合问题，如果测试数据足够强，复杂度不能超过O(n^2)才能AC，如果采用模拟二叉排序树的建立过程，即采用递归的方法将会超时。&lt;/p&gt;

&lt;p&gt;如果我们仔细观察规律，可以发现这个问题可以用dp来解，假设现在n=0,n=1,n=2,….,n=k的解已经求出来，那么对于k+1来说，它的解是什么？我们可以想一下二叉排序数的性质，一个结点左边的儿子分支肯定都小于这个结点，右边的儿子分支肯定都大于这个结点，我们可以把n=k+1的结果看作下面这样组成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1         2          3          4                k         k+1
\        / \        / \        / \     .....   /   \      /
2~k+1   1  3~k+1  1~2 4~k+1  1~3 5~k+1      1~k-1  k+1  1~k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把儿子子树看成一个新的相同的问题，如果儿子子树有m个结点，那这个子树的组合情况就是n=m的解，由此，我们可以得到一个递推公式：&lt;/p&gt;

&lt;p&gt;dp[n] = Σ dp[i-1]*dp[n-i]  (i = 1,2,3,….,n)&lt;/p&gt;

&lt;p&gt;为了能让递推顺利，我们假设dp[0] = 1 .&lt;/p&gt;

&lt;p&gt;如果上面的解递推公式理解了，那就可以很容易的写出代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int numTrees(int n) {
        vector&amp;lt;int&amp;gt; dp(n+1,0);
        if(n&amp;lt;=1) return n;
        dp[0] = 1;
        for(int i = 1 ; i &amp;lt;= n ; ++i){
            for(int j = 1 ; j &amp;lt;=i ; ++j) dp[i] += dp[j-1]*dp[i-j];
        }
        return dp[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中可以看出时间复杂度是O(n^2),由于用到了vector&lt;int&gt;来存储dp，空间复杂度就是O(n)；&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;如果到这里就认为这是最佳解法，你就错了！其实还有O(n)的解法！！那就是用&lt;a href=&quot;http://en.wikipedia.org/wiki/Catalan_number&quot;&gt;卡特兰数&lt;/a&gt;的变换公式。&lt;/p&gt;

&lt;p&gt;我这里简单介绍一下卡特兰数：&lt;/p&gt;

&lt;p&gt;卡特兰数是满足下面递推公式的数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/2/f/1/2f17435a71394ce667ab694b27341560.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以用下面的递推公式表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/8/a/4/8a49332e4a46b3a2c7accec81160f5e3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一个递推公式和我们这道题的dp的递推一模一样，而第二个是卡特兰数的变换递推公式，如果我们用这个公式，显然更简单，而且可以在O(n)时间和O(1)空间下解决问题。代码很简单，就是用第二个递推公式，从n＝1开始，求到n。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int numTrees(int n) {
        long long ans = 1;
        for(int i = 1; i &amp;lt;= n; ++ i)
            ans  = ans * 2 * (2 * i - 1) / (i + 1);
        return (int) ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/10/unique-binary-search-tree</link>
                <guid>http://hombo.wang/leetcode/2014/10/10/unique-binary-search-tree</guid>
                <pubDate>2014-10-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode Surrounded Regions</title>
                <description>&lt;p&gt;这是一道图搜索题，关键在于用DFS或BFS搜索时，处理好边界条件和其他限制条件，例如遇到&lt;code&gt;‘X’&lt;/code&gt;就停止这条路的搜索。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a 2D board containing &lt;code&gt;&#39;X&#39;&lt;/code&gt; and &lt;code&gt;&#39;O&#39;&lt;/code&gt;, capture all regions surrounded by &lt;code&gt;&#39;X&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A region is captured by flipping all ‘O’s into &lt;code&gt;&#39;X&#39;&lt;/code&gt;s in that surrounded region.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X O O X
X X O X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the board should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X X X X
X X X X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;题目的意思是说把这个2D board中完全被&lt;code&gt;&#39;X&#39;&lt;/code&gt;包住的&lt;code&gt;&#39;O&#39;&lt;/code&gt;的区域全部替换为&lt;code&gt;&#39;X&#39;&lt;/code&gt;，就像上面给出的一个例子，内部的三个&lt;code&gt;&#39;O&#39;&lt;/code&gt;被替换了，而边界的&lt;code&gt;&#39;O&#39;&lt;/code&gt;由于没有被包住而不需要替换。&lt;/p&gt;

&lt;p&gt;这道题其实就是一个图的搜索问题，可以把这个2D board看成由几个连通子图构成的，连通子图由全&lt;code&gt;O&lt;/code&gt;或者全&lt;code&gt;X&lt;/code&gt;构成&lt;/p&gt;

&lt;p&gt;搜索的过程是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 从头开始遍历这个2D board， 如果遇到一个`O` ，就从这个`O` 开始进行DFS或者BFS遍历它的连通子图，边界条件就是遇到`X`或者board的边界停止。我们知道连通子图之间是没有路径的，这样就不会对其他子图产生影响。

2. 在遍历的过程中，不断判断是否有`O`在board的边界，如果有，就标记这个子图为`需要替换为‘X’的子图`，在遍历结束后将这个子图中的元素全部替换成`X`。子图的存储可以用一个vector实现。

3. 然后继续在board中往后找没有被访问过的`O`，继续上面的过程，直至结束。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就完成了题目的要求。&lt;/p&gt;

&lt;p&gt;这里用&lt;code&gt;DFS&lt;/code&gt;和&lt;code&gt;BFS&lt;/code&gt;都行，时间复杂度是O(n)，由于要借助一定空间来做标记和存储子图，所以空间复杂度是O(n)&lt;/p&gt;

&lt;p&gt;这个只给出用&lt;code&gt;DFS&lt;/code&gt;AC的代码，&lt;code&gt;BFS&lt;/code&gt;的实现方式把stack换成queue就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) {
        if(board.size()&amp;lt;=2||board[0].size()&amp;lt;=2) return;
        stack&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; s; //DFS stack
        int xsize = board.size(), ysize = board[0].size();
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; record(xsize,vector&amp;lt;bool&amp;gt;(ysize,false)); // 访问标记
        vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; canlist; //存储连通子图
        bool can = true;
        for(int i = 1 ; i &amp;lt; xsize-1 ; ++i){
            for(int j = 1 ; j &amp;lt; ysize-1 ; ++j){ //遍历所有未访问的‘O’
                if(board[i][j] == &#39;O&#39;&amp;amp;&amp;amp;!record[i][j]){
                    can = true;
                    s.push(make_pair(i,j));
                    canlist.push_back(make_pair(i,j));
                    record[i][j] = true;
                    while(!s.empty()){ //DFS
                        pair&amp;lt;int,int&amp;gt; p = s.top();
                        s.pop();
                        if(can&amp;amp;&amp;amp;(p.first==0||p.first==xsize-1||p.second==0||p.second==ysize-1))
                            can = false;
                        if((p.first&amp;gt;0)&amp;amp;&amp;amp;board[p.first-1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first-1][p.second]){
                            s.push(make_pair(p.first-1,p.second));
                            record[p.first-1][p.second] = true;
                            canlist.push_back(make_pair(p.first-1,p.second));
                        }
                        if((p.first&amp;lt;xsize-1)&amp;amp;&amp;amp;board[p.first+1][p.second]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first+1][p.second]){
                            s.push(make_pair(p.first+1,p.second));
                            record[p.first+1][p.second] = true;
                            canlist.push_back(make_pair(p.first+1,p.second));
                        }
                        if((p.second&amp;gt;0)&amp;amp;&amp;amp;board[p.first][p.second-1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second-1]){
                            s.push(make_pair(p.first,p.second-1));
                            record[p.first][p.second-1] = true;
                            canlist.push_back(make_pair(p.first,p.second-1));
                        }
                        if((p.second&amp;lt;ysize-1)&amp;amp;&amp;amp;board[p.first][p.second+1]==&#39;O&#39;&amp;amp;&amp;amp;!record[p.first][p.second+1]){
                            s.push(make_pair(p.first,p.second+1));
                            record[p.first][p.second+1] = true;
                            canlist.push_back(make_pair(p.first,p.second+1));
                        }
                    }
                    if(can){ //改变连通子图中的&#39;O&#39;为‘X’
                        for(int w = 0 ; w &amp;lt; canlist.size() ; ++w)
                            board[canlist[w].first][canlist[w].second] = &#39;X&#39;;
                    }
                    canlist.clear();
                }
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/surrounded-regions</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/surrounded-regions</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Sum Root to Leaf Numbers</title>
                <description>&lt;p&gt;leetcode上比较简单的一道题了，一个二叉树，结点用0～9的数表示，让你求所有从根到叶的连起来的数的加和。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given a binary tree containing digits from &lt;code&gt;0-9&lt;/code&gt; only, each &lt;code&gt;root-to-leaf&lt;/code&gt; path could represent a number.&lt;/p&gt;

&lt;p&gt;An example is the root-to-leaf path &lt;code&gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt; which represents the number &lt;code&gt;123&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Find the total sum of all &lt;code&gt;root-to-leaf&lt;/code&gt; numbers.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
   / \
  2   3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;2&lt;/code&gt; represents the number &lt;code&gt;12&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The root-to-leaf path &lt;code&gt;1-&amp;gt;3&lt;/code&gt; represents the number &lt;code&gt;13&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return the &lt;code&gt;sum = 12 + 13 = 25&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析：&lt;/h2&gt;

&lt;p&gt;要想得到全部的root到leaf的值的总和，我们需要用一个全局的变量sum来保存加和的结果，并且需要父结点向儿子结点传递当前&lt;code&gt;前缀值&lt;/code&gt;，做到这两点，用一次DFS就行了，只需要对树进行一次遍历即可，如果遍历到叶结点，就将这条路径值加到sum。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sum;
    int sumNumbers(TreeNode *root) {
        sum = 0;
        if(root == NULL) return 0;
        travel(root,0);
        return sum;
    }
    void travel(TreeNode *node,int pre){
        if(node-&amp;gt;left == NULL &amp;amp;&amp;amp; node-&amp;gt;right == NULL)
            sum += pre*10+node-&amp;gt;val;
        else{
            if(node-&amp;gt;left != NULL) travel(node-&amp;gt;left,pre*10+node-&amp;gt;val);
            if(node-&amp;gt;right != NULL) travel(node-&amp;gt;right,pre*10+node-&amp;gt;val);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/sum-root-to-leaf-numbers</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Longest Consecutive Sequence</title>
                <description>&lt;p&gt;Given an unsorted array of integers, find the length of the longest consecutive elements sequence. For example,&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;[100, 4, 200, 1, 3, 2]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;The longest consecutive elements sequence is &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;. Return its length: &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your algorithm should run in &lt;code&gt;O(n)&lt;/code&gt; complexity.&lt;/p&gt;

&lt;p&gt;此题可以用hashmap在&lt;code&gt;O(n)&lt;/code&gt; 时间复杂度解决。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;一看是无需数组，又要求&lt;code&gt;O(n)&lt;/code&gt;复杂度实现，很自然的可以想到用hashmap。&lt;/p&gt;

&lt;p&gt;具体方法就是将数组全部hash了，然后在对数组的每个元素进行一边查找，&lt;/p&gt;

&lt;p&gt;例如对于数组的第i个数，我们不断判断&lt;code&gt;num[i]+1&lt;/code&gt;是否在hash表里，如果在说明数组存在比&lt;code&gt;num[i]&lt;/code&gt;大1的数，然后继续判断&lt;code&gt;num[i]+2&lt;/code&gt;……直到&lt;code&gt;num[i]+k&lt;/code&gt;不再hash表里位置，在这个过程中需要记录长度。&lt;/p&gt;

&lt;p&gt;只用上面的算法不能保证是&lt;code&gt;O(n)&lt;/code&gt;的，看下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数组是 `[7,6,5,4,3]`

查找过程是： 

7: `7`
6: `6,7`
5: `5,6,7`
4: `4,5,6,7`
3: `3,4,5,6,7`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然复杂度最坏未为&lt;code&gt;O(n^2)&lt;/code&gt;, 了保证算法是&lt;code&gt;O(n)&lt;/code&gt;的，我们要用一些小技巧，让数组中已经被判断过的数不再去判断，其实很简单，就是加一个标示，表示这个数是否在前面的数里面判断过了，我们还可以将每次判断出来的长度存在这次判断最开始的那个数的hashmap中，这样下次如果加到这个数的时候，可以直接用这个长度值，而不需要往后遍历了，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5: 5,6,7   把长度3存在hashmap : &amp;lt;5,3&amp;gt;
4: 4,5,6,7 当4 上加到5的时候，可以从&amp;lt;5,3&amp;gt;直到5后面连续的长度是3，就不用再遍历了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以保证算法是O(n)的了，空间复杂度是hash表大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int longestConsecutive(vector&amp;lt;int&amp;gt; &amp;amp;num) {
        unordered_map&amp;lt;int,int&amp;gt; hash;
        int max = 0,count,j;
        unordered_map&amp;lt;int,int&amp;gt;::iterator it;
        for(int i = 0 ; i &amp;lt; num.size(); ++i) hash.insert({num[i],-1});
        for(int i = 0 ; i &amp;lt; num.size(); ++i){
            if(hash.find(num[i])-&amp;gt;second!=-1) continue;
            count = 1;
            j = num[i]+1;
            while((it=hash.find(j++))!=hash.end()){
                if(it-&amp;gt;second &amp;gt; 0){
                    count += it-&amp;gt;second;
                    break;
                }
                it-&amp;gt;second = 0;
                ++count;
            }
            hash.find(num[i])-&amp;gt;second = count;
            if(max &amp;lt; count) max = count;
        }
        return max;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，还有一种算法是同时从num[i]的两边不断判断，并标记已经判断过的的数，这种方法可以省去一些长度的记录。&lt;/p&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/06/longest-consecutive-sequence</link>
                <guid>http://hombo.wang/leetcode/2014/10/06/longest-consecutive-sequence</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>无私分享一个翻墙的好方法</title>
                <description>&lt;p&gt;这个翻墙方法是我认为最好的一种，可以随意上facebook，Twitter，Google+等被墙的网站，而且速度非常快，简单易操作。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;方法就是：点击此&lt;a href=&quot;http://pan.baidu.com/s/1hqDuVHE&quot;&gt;hosts&lt;/a&gt;文件，然后下载，把下载的hosts文件替换系统的hosts，不同系统更换hosts的方法不同，下面列出不同系统的hosts文件位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac OS X : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/private/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;最好在shell下用vi来修改，需要用户权限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows XP/Windows 7/Windows 8 : &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C:\WINDOWS\system32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;需要用户权限，建议用vi+sudo来修改&lt;/p&gt;

&lt;p&gt;替换了系统的hosts文件后就可以用你的浏览器翻墙了！&lt;/p&gt;

&lt;h3 id=&quot;https&quot;&gt;注意！！上国外的网站时一定要记得在网站前面加&lt;code&gt;https://&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;例如：https://www.facebook.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个hosts文件我会定期更新，敬请关注！&lt;/p&gt;
</description>
                <link>http://hombo.wang/hosts/2014/10/06/hosts</link>
                <guid>http://hombo.wang/hosts/2014/10/06/hosts</guid>
                <pubDate>2014-10-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>swap两个int指针指向的数</title>
                <description>&lt;p&gt;这是一道最近的面试题，感谢斌哥的奉献！
题目是： 填写下面的函数，实现a和b指针指向的两个数的交换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = ________ ;
    b = ________ ;
    a = ________ ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;分析:&lt;/h2&gt;

&lt;p&gt;我们知道对于两个数a,b的交换，如果不借助其他变量，也是可以实现的，方法有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用加减法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用加减法的 &lt;code&gt;交换律&lt;/code&gt; 和 &lt;code&gt;结合律&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a + b;
    b = a - b; //b = a + b - b = a 
    a = a - b; //a = a + b - a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;用乘除法:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，这个方法需要满足 &lt;code&gt;a*b != 0&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a * b;
    b = a / b; //b = a * b / b = a 
    a = a / b; //a = a * b / a = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这个方法用到了乘除法的 &lt;code&gt;分配率&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用异或运算：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用异或的性质: &lt;code&gt;交换律&lt;/code&gt; , &lt;code&gt;结合律&lt;/code&gt;  , &lt;code&gt;a ^ a = 0&lt;/code&gt; , &lt;code&gt;0 ^ a = a&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int a , int b){
    a = a ^ b;
    b = a ^ b; //b = a ^ b ^ b = a ^ 0 = a 
    a = a ^ b; //a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而本题给的是指针，而且等式左边都是指针，也就是说没办法直接改变指针指向的内存位置的值，那怎么办呢？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法:&lt;/h2&gt;

&lt;p&gt;虽然等式左边没有给出&lt;a href=&quot;http://baike.baidu.com/view/836474.htm?fr=aladdin&quot;&gt;左值&lt;/a&gt;,但我们可以在等式右边加入左值，也就是说可以写成这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*a = *a + *b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了不改变指针的值，还需要用点小技巧，就是用“,”来分割语句，可以写成下面这种形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = (*a = *a + *b , a )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为用“,”分割的语句，语句的返回值是最后一个子语句，这里就是a。现在应该明白了吧！那本题的一种解法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a , int *b){
    a = (*a = *a + *b , a);
    b = (*b = *a - *b , b); //*b = *a + *b - *b = *a 
    a = (*a = *a - *b , a); //*a = *a + *b - *a = *b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用乘除法和异或运算来实现，大同小异，这里不再给出。&lt;/p&gt;
</description>
                <link>http://hombo.wang/algorithm/2014/10/05/swap-two-int</link>
                <guid>http://hombo.wang/algorithm/2014/10/05/swap-two-int</guid>
                <pubDate>2014-10-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Leetcode TwoSum</title>
                <description>&lt;p&gt;这是一道基本的数组查找问题，需要O(n)的时间复杂度才能AC，有两种解答方法，一种是用排序和双指针，另一种是用hash表，下面具体来说。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;原文题目：&lt;/h2&gt;

&lt;p&gt;Given an array of integers, find two numbers such that they add up to a specific target number.&lt;/p&gt;

&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;hash表解法:&lt;/h2&gt;

&lt;p&gt;这种解法很简单，就是建立 &amp;lt;numbers[i],i&amp;gt; 这一对索引，遍历一遍numbers， 然后用target-numbers[i] 去找hash 表 ，如果存在 ，取出i，搞定!&lt;/p&gt;

&lt;p&gt;时间复杂度是O(n), 空间复杂度是hash表的大小。&lt;/p&gt;

&lt;p&gt;AC代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target){
    unordered_map&amp;lt;int, int&amp;gt; hash;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; numbers.size(); i++{
        int numberToFind = target - numbers[i];
        if (hash.find(numberToFind) != hash.end()) {
            result.push_back(hash[numberToFind] + 1);
            result.push_back(i + 1);            
            return result;
        }
        hash[numbers[i]] = i;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;快速排序+双指针解法：&lt;/h2&gt;

&lt;p&gt;先将numbers数组从小到大进行快速排序，然后一个index i 从numbers[0]开始，另一个index j 从numbers的结束开始，往中间靠拢。在这个靠拢过程中，如果numbers[i] + numbers[j] &amp;lt; target 说明加和的值还不够，需要继续增加，那只能增大i了（因为numbers从小到大排序），如果numbers[i] + numbers[j] &amp;gt; target 说明加和的值大了，需要减小点，那也只能减小j了，如果numbers[i] + numbers[j] == target , 那说明我们找到了答案。由于题目要求给出原来数组中的位置，并且第一个数位置为1（而不是0），因此我们需要一个额外的数组暂存原来的数组，然后找到在原始数组中的位置。&lt;/p&gt;

&lt;p&gt;算法的时间复杂度是：快排O(nlogn) + 双指针O(n) + 找位置 O(n)  = O(nlogn) ，由于用到了一个额外数组，空间复杂度是O(n)。&lt;/p&gt;

&lt;p&gt;AC的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt; &amp;amp;numbers, int target) {
        vector&amp;lt;int&amp;gt; result,tmp = numbers;
        int a = 0,b = 0;
        sort(tmp.begin(),tmp.end());
        int i = 0 ,j = tmp.size()-1;
        while(i&amp;lt;j){
            if(tmp[i]+tmp[j] == target) break;
            else if (tmp[i]+tmp[j] &amp;gt; target) --j;
            else ++i;
        }
        for(int w = 0 ; (!a||!b)&amp;amp;&amp;amp;w &amp;lt; numbers.size();++w){
            if((!a)&amp;amp;&amp;amp;numbers[w] == tmp[i]) a = w+1;
            else if(numbers[w] == tmp[j]) b = w+1;
        }
        result.push_back(a&amp;lt;b?a:b);
        result.push_back(a&amp;gt;b?a:b);
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://hombo.wang/leetcode/2014/10/05/Two-Sum</link>
                <guid>http://hombo.wang/leetcode/2014/10/05/Two-Sum</guid>
                <pubDate>2014-10-05T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
